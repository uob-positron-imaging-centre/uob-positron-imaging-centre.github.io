<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.3" />
<title>pept.base.voxel_data API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pept.base.voxel_data</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-


#    pept is a Python library that unifies Positron Emission Particle
#    Tracking (PEPT) research, including tracking, simulation, data analysis
#    and visualisation tools.
#
#    If you used this codebase or any software making use of it in a scientific
#    publication, you must cite the following paper:
#        Nicu≈üan AL, Windows-Yule CR. Positron emission particle tracking
#        using machine learning. Review of Scientific Instruments.
#        2020 Jan 1;91(1):013329.
#        https://doi.org/10.1063/1.5129251
#
#    Copyright (C) 2020 Andrei Leonard Nicusan
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.


# File   : voxel_data.py
# License: License: GNU v3.0
# Author : Andrei Leonard Nicusan &lt;a.l.nicusan@bham.ac.uk&gt;
# Date   : 07.01.2020


import  time
import  numpy                   as      np

import  plotly.graph_objects    as      go

import  matplotlib
import  matplotlib.pyplot       as      plt
from    matplotlib.colors       import  Normalize
from    mpl_toolkits.mplot3d    import  Axes3D

from    pept.utilities.traverse import  traverse3d


class VoxelData:


    def __init__(
        self,
        line_data,
        volume_limits = [500., 500., 500.],
        number_of_voxels = [10, 10, 10],
        traverse = True,
        verbose = False
    ):

        if verbose:
            start = time.time()

        # If `line_data` is not C-contiguous, create a C-contiguous copy
        self._line_data = np.asarray(line_data, order = &#39;C&#39;, dtype = float)
        # Check that line_data has shape (N, 7)
        if self._line_data.ndim != 2 or self._line_data.shape[1] != 7:
            raise ValueError(&#39;\n[ERROR]: line_data should have dimensions (N, 7). Received {}\n&#39;.format(self._line_data.shape))

        self._number_of_lines = len(self._line_data)

        # If `volume_limits` is not C-contiguous, create a C-contiguous copy
        self._volume_limits = np.asarray(volume_limits, dtype = float, order = &#34;C&#34;)
        # Check that volume_limits has shape (3,)
        if self._volume_limits.ndim != 1 or self._volume_limits.shape[0] != 3:
            raise ValueError(&#34;\n[ERROR]: volume_limits should have dimensions (3,). Received {}\n&#34;.format(self._volume_limits.shape))

        # If `number_of_voxels` is not C-contiguous, create a C-contiguous copy
        self._number_of_voxels = np.asarray(number_of_voxels, dtype = int, order = &#34;C&#34;)
        # Check that number_of_voxels has shape(3,)
        if self._number_of_voxels.ndim != 1 or self._number_of_voxels.shape[0] != 3:
            raise ValueError(&#34;\n[ERROR]: number_of_voxels should have dimensions (3,). Received {}\n&#34;.format(self._number_of_voxels.shape))

        self._voxel_sizes = self._volume_limits / self._number_of_voxels

        # If, for dimension x, there are 5 voxels between coordinates 0
        # and 5, then the delimiting grid is [0, 1, 2, 3, 4, 5].
        self._voxel_grid = [np.linspace(0, self._volume_limits[i], self._number_of_voxels[i] + 1) for i in range(3)]

        # All access to voxel_positions will be done directly through the inner
        # class _VoxelPositions, so no need for a private property here
        self.voxel_positions = self._VoxelPositions(self._volume_limits, self._number_of_voxels)
        self._voxel_data = np.zeros(self._number_of_voxels, dtype = int)

        if traverse:
            if verbose:
                start_traverse = time.time()

            if traverse == True:
                self.traverse()
            else:
                self.traverse(traverse)

            if verbose:
                end_traverse = time.time()

        if verbose:
            end = time.time()
            print(&#34;Initialising the instance of VoxelData took {} seconds.\n&#34;.format(end - start))
            if traverse:
                print(&#34;Traversing all voxels took {} seconds.\n&#34;.format(end_traverse - start_traverse))


    class _VoxelPositions:

        def __init__(self, volume_limits, number_of_voxels):

            self.volume_limits = np.asarray(volume_limits, dtype = float, order = &#34;C&#34;)
            self.number_of_voxels = np.asarray(number_of_voxels, dtype = int, order = &#34;C&#34;)
            self.voxel_sizes = self.volume_limits / self.number_of_voxels

            self._index = 0


        def at(self, ix, iy, iz):
            # Evaluate the position of the voxel (the centre of it) at indices
            # [ix, iy, iz]

            indices = np.array([ix, iy, iz], dtype = int)

            if (indices &gt;= self.number_of_voxels).any() or (indices &lt; 0).any():
                raise IndexError(&#34;[ERROR]: Each of the [ix, iy, iz] indices must be between 0 and the corresponding `number_of_voxels`.&#34;)

            return self._at(indices)


        def _at(self, indices):
            # Unchecked!
            return self.voxel_sizes * (0.5 + indices)


        def at_corner(self, ix, iy, iz):
            # Evaluate the position of the voxel (the corner of it) at indices
            # [ix, iy, iz]

            indices = np.array([ix, iy, iz], dtype = int)

            if (indices &gt;= self.number_of_voxels).any() or (indices &lt; 0).any():
                raise IndexError(&#34;[ERROR]: Each of the [ix, iy, iz] indices must be between 0 and the corresponding `number_of_voxels`.&#34;)

            return self._at_corner(indices)


        def _at_corner(self, indices):
            # Unchecked!
            return self.voxel_sizes * indices


        def all(self):

            positions = []
            for i in range(self.number_of_voxels[0]):
                for j in range(self.number_of_voxels[1]):
                    for k in range(self.number_of_voxels[2]):
                        positions.append(self._at(np.array([i, j, k])))

            return np.array(positions)


        def __len__(self):
            return self.number_of_voxels[0]


        def __getitem__(self, key):

            if not isinstance(key, tuple):
                key = (key,)

            if len(key) &gt; 3:
                raise ValueError(&#34;[ERROR]: The accessor takes maximum 3 indices, {} were given.&#34;.format(len(key)))

            # Calculate the starting and ending indices and the step for the
            # [x, y, z] coordinates of all the elements that are accessed.
            # The default (:, :, :) is the whole range.
            start = [0, 0, 0]
            stop = list(self.number_of_voxels)
            step = [1, 1, 1]

            # The ranges of data selection for each dimension. Default is a
            # range, but can be an explicit list too (e.g. select elements
            # [1,2,5]).
            xyz_ranges = [range(stop[i]) for i in range(3)]

            # Handles negative indices for each of the 3 dimensions.
            def make_positive(index, dimension):
                while index &lt; 0:
                    index += self.number_of_voxels[dimension]
                return index

            # Interpret each key
            for i in range(len(key)):
                # If key[i] is an int, only access the elements at that index,
                # equivalent to range(key[i], key[i] + 1, 1).
                if isinstance(key[i], (int, np.integer)):
                    if key[i] &gt;= self.number_of_voxels[i]:
                        raise IndexError(&#34;[ERROR]: Tried to access voxel number {} (indexed from 0), when there are {} voxels for dimension {}.&#34;.format(key[i], self.number_of_voxels[i], i))

                    index = make_positive(key[i], i)
                    start[i] = index
                    stop[i] = index + 1

                    xyz_ranges[i] = range(start[i], stop[i], step[i])

                # Interpret the possible slices (1:5, ::-1, etc.).
                elif isinstance(key[i], slice):
                    # First interpret the step for the ::-1 corner case.
                    if key[i].step is not None:
                        if not isinstance(key[i].step, (int, np.integer)):
                            raise TypeError(&#34;Slice step must be an int. Received {}.&#34;.format(type(key[i].step)))
                        if key[i].step == 0:
                            raise ValueError(&#34;Slice step cannot be zero.&#34;)
                        elif key[i].step &lt; 0:
                            # If the step is negative, the default start and
                            # stop become (max_index - 1) and -1, such that
                            # ::-1 works.
                            start[i] = self.number_of_voxels[i] - 1
                            stop[i] = -1
                            step[i] = key[i].step
                        else:
                            step[i] = key[i].step

                    if key[i].start is not None:
                        if not isinstance(key[i].start, (int, np.integer)):
                            raise TypeError(&#34;Slice start must be an int. Received {}.&#34;.format(type(key[i].start)))
                        # Corner case: x = [1,2,3] =&gt; x[5:10] == []
                        start[i] = min(make_positive(key[i].start, i), self.number_of_voxels[i])

                    if key[i].stop is not None:
                        if not isinstance(key[i].stop, (int, np.integer)):
                            raise TypeError(&#34;Slice stop must be an int. Received {}.&#34;.format(type(key[i].stop)))
                        # Corner case: x = [1,2,3] =&gt; x[5:10] == []
                        stop[i] = min(make_positive(key[i].stop, i), self.number_of_voxels[i])

                    xyz_ranges[i] = range(start[i], stop[i], step[i])

                # Interpret iterable sequence of selected elements
                elif hasattr(key[i], &#34;__iter__&#34;):
                    xyz_ranges[i] = np.asarray(key[i], dtype = int)

                else:
                    raise TypeError(&#34;Indices must be either `int`, `slice` or iterable of `int`s. Received {}.&#34;.format(type(key[i])))

            positions = []
            # Iterate through all the elements that need to be accessed
            for x in xyz_ranges[0]:
                for y in xyz_ranges[1]:
                    for z in xyz_ranges[2]:
                        positions.append(self._at(np.array([x, y, z])))

            if len(positions) == 1:
                return positions[0]
            else:
                return np.array(positions)


        def __iter__(self):
            return self


        def __next__(self):
            if self._index &gt;= len(self):
                self._index = 0
                raise StopIteration

            self._index += 1
            return self[self._index - 1]


    @property
    def line_data(self):
        return self._line_data


    @property
    def number_of_lines(self):
        return self._number_of_lines


    @property
    def volume_limits(self):
        return self._volume_limits


    @volume_limits.setter
    def volume_limits(self, volume_limits):
        # If `volume_limits` is not C-contiguous, create a C-contiguous copy
        self._volume_limits = np.asarray(volume_limits, dtype = float, order = &#34;C&#34;)
        # Check that volume_limits has shape (3,)
        if self._volume_limits.ndim != 1 or self._volume_limits.shape[0] != 3:
            raise ValueError(&#34;\n[ERROR]: volume_limits should have dimensions (3,). Received {}\n&#34;.format(self._volume_limits.shape))

        self._voxel_sizes = self._volume_limits / self._number_of_voxels

        # If, for dimension x, there are 5 voxels between coordinates 0
        # and 5, then the delimiting grid is [0, 1, 2, 3, 4, 5].
        self._voxel_grid = [np.linspace(0, self._volume_limits[i], self._number_of_voxels[i] + 1) for i in range(3)]

        # All access to voxel_positions will be done directly through the inner
        # class _VoxelPositions, so no need for a private property here
        self.voxel_positions = self._VoxelPositions(self._volume_limits, self._number_of_voxels)
        self._voxel_data = np.zeros(self._number_of_voxels, dtype = int)


    @property
    def number_of_voxels(self):
        return self._number_of_voxels


    @number_of_voxels.setter
    def number_of_voxels(self, number_of_voxels):
        # If `number_of_voxels` is not C-contiguous, create a C-contiguous copy
        self._number_of_voxels = np.asarray(number_of_voxels, dtype = int, order = &#34;C&#34;)
        # Check that number_of_voxels has shape(3,)
        if self._number_of_voxels.ndim != 1 or self._number_of_voxels.shape[0] != 3:
            raise ValueError(&#34;\n[ERROR]: number_of_voxels should have dimensions (3,). Received {}\n&#34;.format(self._number_of_voxels.shape))

        self._voxel_sizes = self._volume_limits / self._number_of_voxels

        # If, for dimension x, there are 5 voxels between coordinates 0
        # and 5, then the delimiting grid is [0, 1, 2, 3, 4, 5].
        self._voxel_grid = [np.linspace(0, self._volume_limits[i], self._number_of_voxels[i] + 1) for i in range(3)]

        # All access to voxel_positions will be done directly through the inner
        # class _VoxelPositions, so no need for a private property here
        self.voxel_positions = self._VoxelPositions(self._volume_limits, self._number_of_voxels)
        self._voxel_data = np.zeros(self._number_of_voxels, dtype = int)


    @property
    def voxel_sizes(self):
        return self._voxel_sizes


    @property
    def voxel_grid(self):
        return self._voxel_grid


    @property
    def voxel_data(self):
        return self._voxel_data


    def traverse_python(self, lor_indices = None):
        # Adapted from &#34;A Fast Voxel Traversal Algorithm for Ray Tracing&#34; by
        # John Amanatides and Andrew Woo.

        # Traverse voxels for all LoRs by default
        if lor_indices is None:
            lor_indices = range(self._number_of_lines)

        if not hasattr(lor_indices, &#34;__iter__&#34;):
            raise TypeError(&#34;[ERROR]: The `lor_indices` parameter must be iterable.&#34;)

        # The adapted grid traversal algorithm
        for li in lor_indices:
            # Define a line as L(t) = U + t V
            # If an LoR is defined as two points P1 and P2, then
            # U = P1 and V = P2 - P1
            p1 = self._line_data[li, 1:4]
            p2 = self._line_data[li, 4:7]
            u = p1
            v = p2 - p1

            ##############################################################
            # Initialisation stage

            # The step [sx, sy, sz] defines the sense of the LoR.
            # If V[0] is positive, then sx = 1
            # If V[0] is negative, then sx = -1
            step = np.array([1, 1, 1], dtype = int)
            for i, c in enumerate(v):
                if c &lt; 0:
                    step[i] = -1

            # The current voxel indices [ix, iy, iz] that the line passes
            # through.
            voxel_index = np.array([0, 0, 0], dtype = int)

            # The value of t at which the line passes through to the next
            # voxel, for each dimension.
            t_next = np.array([0., 0., 0.], dtype = float)

            # Find the initial voxel that the line starts from, for each
            # dimension.
            for i in range(len(voxel_index)):
                # If, for dimension x, there are 5 voxels between coordinates 0
                # and 5, then the delimiting grid is [0, 1, 2, 3, 4, 5].
                # If the line starts at 1.5, then it is part of the voxel at
                # index 1.
                voxel_index[i] = np.searchsorted(self._voxel_grid[i], u[i], side = &#34;right&#34;) - 1

                # If the line is going &#34;up&#34;, the next voxel is the next one
                if v[i] &gt;= 0:
                    offset = 1
                # If the line is going &#34;down&#34;, the next voxel is the current one
                else:
                    offset = 0
                t_next[i] = (self._voxel_grid[i][voxel_index[i] + offset] - u[i]) / v[i]

            # delta_t indicates how far along the ray we must move (in units of
            # t) for each component to be equal to the size of the voxel in
            # that dimension.
            delta_t = np.abs(self._voxel_sizes / v)

            ###############################################################
            # Incremental traversal stage

            # Loop until we reach the last voxel in space
            while (voxel_index &lt; self._number_of_voxels).all() and (voxel_index &gt;= 0).all():

                self._voxel_data[tuple(voxel_index)] += 1

                # If p2 is fully bounded by the voxel, stop the algorithm
                if ((self.voxel_positions._at_corner(voxel_index) &lt; p2).all() and
                    (self.voxel_positions._at_corner(voxel_index + 1) &gt; p2).all()):
                    break

                # The dimension of the minimum t that makes the line pass
                # through to the next voxel
                min_i = t_next.argmin()
                t_next[min_i] += delta_t[min_i]
                voxel_index[min_i] += step[min_i]


    def traverse(self, lor_indices = None):
        # Traverse all intersecting voxels for selected LoRs.

        # Traverse voxels for all LoRs by default
        if lor_indices is None:
            lor_indices = range(self._number_of_lines)

        if not hasattr(lor_indices, &#34;__iter__&#34;):
            raise TypeError(&#34;[ERROR]: The `lor_indices` parameter must be iterable.&#34;)

        traverse3d(
            self._voxel_data,
            self._line_data[lor_indices],
            self._voxel_grid[0],
            self._voxel_grid[1],
            self._voxel_grid[2]
        )


    def indices(self, coords):
        # Find the voxel indices for a point at `coords`
        coords = np.asarray(coords, dtype = float)
        if coords.ndim != 1 or coords.shape[0] != 3:
            raise ValueError(&#34;The `coords` parameter must have shape (3,). Received {}.&#34;.format(coords))

        indices = np.array([0, 0, 0], dtype = int)
        for i in range(3):
            indices[i] = np.searchsorted(self._voxel_grid[i], coords[i], side = &#34;right&#34;) - 1

        return indices


    def cube_trace(self, index, opacity = 0.4, color = None, colorscale = False):
        # For a small number of cubes

        index = np.asarray(index, dtype = int)
        xyz = self.voxel_positions.at_corner(*index)

        x = np.array([0, 0, 1, 1, 0, 0, 1, 1]) * self._voxel_sizes[0]
        y = np.array([0, 1, 1, 0, 0, 1, 1, 0]) * self._voxel_sizes[1]
        z = np.array([0, 0, 0, 0, 1, 1, 1, 1]) * self._voxel_sizes[2]
        i = np.array([7, 0, 0, 0, 4, 4, 6, 6, 4, 0, 3, 2])
        j = np.array([3, 4, 1, 2, 5, 6, 5, 2, 0, 1, 6, 3])
        k = np.array([0, 7, 2, 3, 6, 7, 1, 1, 5, 5, 7, 6])

        cube = dict(
            x =  x + xyz[0],
            y =  y + xyz[1],
            z =  z + xyz[2],
            i =  i,
            j =  j,
            k =  k,
            opacity = opacity,
            color = color
        )

        if colorscale:
            cmap = matplotlib.cm.get_cmap(&#34;magma&#34;)
            c = cmap(self._voxel_data[tuple(index)] / (self._voxel_data.max() or 1))
            cube.update(
                color = &#34;rgb({},{},{})&#34;.format(c[0], c[1], c[2])
            )

        return go.Mesh3d(cube)


    def cubes_traces(
        self,
        condition = lambda voxel_data: voxel_data &gt; 0,
        opacity = 0.4,
        color = None,
        colorscale = False
    ):
        # For a small number of cubes

        indices = np.argwhere(condition(self._voxel_data))
        traces = [self.cube_trace(i, opacity = opacity, color = color, colorscale = colorscale) for i in indices]

        return traces


    def voxels_trace(
        self,
        condition = lambda voxel_data: voxel_data &gt; 0,
        size = 4,
        opacity = 0.4,
        color = None,
        colorscale = False
    ):
        # For a large number of cubes

        filtered_indices = np.argwhere(condition(self._voxel_data))
        positions = self.voxel_positions._at(filtered_indices)

        marker = dict(
            size = size,
            color = color,
            symbol = &#34;square&#34;
        )

        if colorscale:
            cvalues = [self._voxel_data[tuple(t)] for t in filtered_indices]
            marker.update(colorscale = &#34;Magma&#34;, color = cvalues)

        voxels = dict(
            x = positions[:, 0],
            y = positions[:, 1],
            z = positions[:, 2],
            opacity = opacity,
            mode = &#34;markers&#34;,
            marker = marker
        )

        return go.Scatter3d(voxels)


    def heatmap_trace(
        self,
        ix = None,
        iy = None,
        iz = None,
        width = 0
    ):

        if ix is not None:
            x = self._voxel_grid[1]
            y = self._voxel_grid[2]
            z = self._voxel_data[ix, :, :]

            for i in range(1, width + 1):
                z = z + self._voxel_data[ix + i, :, :]
                z = z + self._voxel_data[ix - i, :, :]

        elif iy is not None:
            x = self._voxel_grid[0]
            y = self._voxel_grid[2]
            z = self._voxel_data[:, iy, :]

            for i in range(1, width + 1):
                z = z + self._voxel_data[:, iy + i, :]
                z = z + self._voxel_data[:, iy - i, :]

        elif iz is not None:
            x = self._voxel_grid[0]
            y = self._voxel_grid[1]
            z = self._voxel_data[:, :, iz]

            for i in range(1, width + 1):
                z = z + self._voxel_data[:, :, iz + i]
                z = z + self._voxel_data[:, :, iz - i]

        else:
            raise ValueError(&#34;[ERROR]: One of the `ix`, `iy`, `iz` slice indices must be provided.&#34;)

        heatmap = dict(
            x = x,
            y = y,
            z = z,
            colorscale = &#34;Magma&#34;,
            transpose = True
        )

        return go.Heatmap(heatmap)


    def __str__(self):
        # Shown when calling print(class)
        docstr = &#34;&#34;

        docstr += &#34;number_of_lines =   {}\n\n&#34;.format(self.number_of_lines)
        docstr += &#34;volume_limits =     {}\n&#34;.format(self.volume_limits)
        docstr += &#34;number_of_voxels =  {}\n&#34;.format(self.number_of_voxels)
        docstr += &#34;voxel_sizes =       {}\n\n&#34;.format(self.voxel_sizes)

        docstr += &#34;line_data = \n&#34;
        docstr += self._line_data.__str__()

        docstr += &#34;\n\nvoxel_data = \n&#34;
        docstr += self._voxel_data.__str__()

        return docstr


    def __repr__(self):
        # Shown when writing the class on a REPR

        docstr = &#34;Class instance that inherits from `pept.VoxelData`.\n\n&#34; + self.__str__() + &#34;\n\n&#34;

        return docstr</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pept.base.voxel_data.VoxelData"><code class="flex name class">
<span>class <span class="ident">VoxelData</span></span>
<span>(</span><span>line_data, volume_limits=[500.0, 500.0, 500.0], number_of_voxels=[10, 10, 10], traverse=True, verbose=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class VoxelData:


    def __init__(
        self,
        line_data,
        volume_limits = [500., 500., 500.],
        number_of_voxels = [10, 10, 10],
        traverse = True,
        verbose = False
    ):

        if verbose:
            start = time.time()

        # If `line_data` is not C-contiguous, create a C-contiguous copy
        self._line_data = np.asarray(line_data, order = &#39;C&#39;, dtype = float)
        # Check that line_data has shape (N, 7)
        if self._line_data.ndim != 2 or self._line_data.shape[1] != 7:
            raise ValueError(&#39;\n[ERROR]: line_data should have dimensions (N, 7). Received {}\n&#39;.format(self._line_data.shape))

        self._number_of_lines = len(self._line_data)

        # If `volume_limits` is not C-contiguous, create a C-contiguous copy
        self._volume_limits = np.asarray(volume_limits, dtype = float, order = &#34;C&#34;)
        # Check that volume_limits has shape (3,)
        if self._volume_limits.ndim != 1 or self._volume_limits.shape[0] != 3:
            raise ValueError(&#34;\n[ERROR]: volume_limits should have dimensions (3,). Received {}\n&#34;.format(self._volume_limits.shape))

        # If `number_of_voxels` is not C-contiguous, create a C-contiguous copy
        self._number_of_voxels = np.asarray(number_of_voxels, dtype = int, order = &#34;C&#34;)
        # Check that number_of_voxels has shape(3,)
        if self._number_of_voxels.ndim != 1 or self._number_of_voxels.shape[0] != 3:
            raise ValueError(&#34;\n[ERROR]: number_of_voxels should have dimensions (3,). Received {}\n&#34;.format(self._number_of_voxels.shape))

        self._voxel_sizes = self._volume_limits / self._number_of_voxels

        # If, for dimension x, there are 5 voxels between coordinates 0
        # and 5, then the delimiting grid is [0, 1, 2, 3, 4, 5].
        self._voxel_grid = [np.linspace(0, self._volume_limits[i], self._number_of_voxels[i] + 1) for i in range(3)]

        # All access to voxel_positions will be done directly through the inner
        # class _VoxelPositions, so no need for a private property here
        self.voxel_positions = self._VoxelPositions(self._volume_limits, self._number_of_voxels)
        self._voxel_data = np.zeros(self._number_of_voxels, dtype = int)

        if traverse:
            if verbose:
                start_traverse = time.time()

            if traverse == True:
                self.traverse()
            else:
                self.traverse(traverse)

            if verbose:
                end_traverse = time.time()

        if verbose:
            end = time.time()
            print(&#34;Initialising the instance of VoxelData took {} seconds.\n&#34;.format(end - start))
            if traverse:
                print(&#34;Traversing all voxels took {} seconds.\n&#34;.format(end_traverse - start_traverse))


    class _VoxelPositions:

        def __init__(self, volume_limits, number_of_voxels):

            self.volume_limits = np.asarray(volume_limits, dtype = float, order = &#34;C&#34;)
            self.number_of_voxels = np.asarray(number_of_voxels, dtype = int, order = &#34;C&#34;)
            self.voxel_sizes = self.volume_limits / self.number_of_voxels

            self._index = 0


        def at(self, ix, iy, iz):
            # Evaluate the position of the voxel (the centre of it) at indices
            # [ix, iy, iz]

            indices = np.array([ix, iy, iz], dtype = int)

            if (indices &gt;= self.number_of_voxels).any() or (indices &lt; 0).any():
                raise IndexError(&#34;[ERROR]: Each of the [ix, iy, iz] indices must be between 0 and the corresponding `number_of_voxels`.&#34;)

            return self._at(indices)


        def _at(self, indices):
            # Unchecked!
            return self.voxel_sizes * (0.5 + indices)


        def at_corner(self, ix, iy, iz):
            # Evaluate the position of the voxel (the corner of it) at indices
            # [ix, iy, iz]

            indices = np.array([ix, iy, iz], dtype = int)

            if (indices &gt;= self.number_of_voxels).any() or (indices &lt; 0).any():
                raise IndexError(&#34;[ERROR]: Each of the [ix, iy, iz] indices must be between 0 and the corresponding `number_of_voxels`.&#34;)

            return self._at_corner(indices)


        def _at_corner(self, indices):
            # Unchecked!
            return self.voxel_sizes * indices


        def all(self):

            positions = []
            for i in range(self.number_of_voxels[0]):
                for j in range(self.number_of_voxels[1]):
                    for k in range(self.number_of_voxels[2]):
                        positions.append(self._at(np.array([i, j, k])))

            return np.array(positions)


        def __len__(self):
            return self.number_of_voxels[0]


        def __getitem__(self, key):

            if not isinstance(key, tuple):
                key = (key,)

            if len(key) &gt; 3:
                raise ValueError(&#34;[ERROR]: The accessor takes maximum 3 indices, {} were given.&#34;.format(len(key)))

            # Calculate the starting and ending indices and the step for the
            # [x, y, z] coordinates of all the elements that are accessed.
            # The default (:, :, :) is the whole range.
            start = [0, 0, 0]
            stop = list(self.number_of_voxels)
            step = [1, 1, 1]

            # The ranges of data selection for each dimension. Default is a
            # range, but can be an explicit list too (e.g. select elements
            # [1,2,5]).
            xyz_ranges = [range(stop[i]) for i in range(3)]

            # Handles negative indices for each of the 3 dimensions.
            def make_positive(index, dimension):
                while index &lt; 0:
                    index += self.number_of_voxels[dimension]
                return index

            # Interpret each key
            for i in range(len(key)):
                # If key[i] is an int, only access the elements at that index,
                # equivalent to range(key[i], key[i] + 1, 1).
                if isinstance(key[i], (int, np.integer)):
                    if key[i] &gt;= self.number_of_voxels[i]:
                        raise IndexError(&#34;[ERROR]: Tried to access voxel number {} (indexed from 0), when there are {} voxels for dimension {}.&#34;.format(key[i], self.number_of_voxels[i], i))

                    index = make_positive(key[i], i)
                    start[i] = index
                    stop[i] = index + 1

                    xyz_ranges[i] = range(start[i], stop[i], step[i])

                # Interpret the possible slices (1:5, ::-1, etc.).
                elif isinstance(key[i], slice):
                    # First interpret the step for the ::-1 corner case.
                    if key[i].step is not None:
                        if not isinstance(key[i].step, (int, np.integer)):
                            raise TypeError(&#34;Slice step must be an int. Received {}.&#34;.format(type(key[i].step)))
                        if key[i].step == 0:
                            raise ValueError(&#34;Slice step cannot be zero.&#34;)
                        elif key[i].step &lt; 0:
                            # If the step is negative, the default start and
                            # stop become (max_index - 1) and -1, such that
                            # ::-1 works.
                            start[i] = self.number_of_voxels[i] - 1
                            stop[i] = -1
                            step[i] = key[i].step
                        else:
                            step[i] = key[i].step

                    if key[i].start is not None:
                        if not isinstance(key[i].start, (int, np.integer)):
                            raise TypeError(&#34;Slice start must be an int. Received {}.&#34;.format(type(key[i].start)))
                        # Corner case: x = [1,2,3] =&gt; x[5:10] == []
                        start[i] = min(make_positive(key[i].start, i), self.number_of_voxels[i])

                    if key[i].stop is not None:
                        if not isinstance(key[i].stop, (int, np.integer)):
                            raise TypeError(&#34;Slice stop must be an int. Received {}.&#34;.format(type(key[i].stop)))
                        # Corner case: x = [1,2,3] =&gt; x[5:10] == []
                        stop[i] = min(make_positive(key[i].stop, i), self.number_of_voxels[i])

                    xyz_ranges[i] = range(start[i], stop[i], step[i])

                # Interpret iterable sequence of selected elements
                elif hasattr(key[i], &#34;__iter__&#34;):
                    xyz_ranges[i] = np.asarray(key[i], dtype = int)

                else:
                    raise TypeError(&#34;Indices must be either `int`, `slice` or iterable of `int`s. Received {}.&#34;.format(type(key[i])))

            positions = []
            # Iterate through all the elements that need to be accessed
            for x in xyz_ranges[0]:
                for y in xyz_ranges[1]:
                    for z in xyz_ranges[2]:
                        positions.append(self._at(np.array([x, y, z])))

            if len(positions) == 1:
                return positions[0]
            else:
                return np.array(positions)


        def __iter__(self):
            return self


        def __next__(self):
            if self._index &gt;= len(self):
                self._index = 0
                raise StopIteration

            self._index += 1
            return self[self._index - 1]


    @property
    def line_data(self):
        return self._line_data


    @property
    def number_of_lines(self):
        return self._number_of_lines


    @property
    def volume_limits(self):
        return self._volume_limits


    @volume_limits.setter
    def volume_limits(self, volume_limits):
        # If `volume_limits` is not C-contiguous, create a C-contiguous copy
        self._volume_limits = np.asarray(volume_limits, dtype = float, order = &#34;C&#34;)
        # Check that volume_limits has shape (3,)
        if self._volume_limits.ndim != 1 or self._volume_limits.shape[0] != 3:
            raise ValueError(&#34;\n[ERROR]: volume_limits should have dimensions (3,). Received {}\n&#34;.format(self._volume_limits.shape))

        self._voxel_sizes = self._volume_limits / self._number_of_voxels

        # If, for dimension x, there are 5 voxels between coordinates 0
        # and 5, then the delimiting grid is [0, 1, 2, 3, 4, 5].
        self._voxel_grid = [np.linspace(0, self._volume_limits[i], self._number_of_voxels[i] + 1) for i in range(3)]

        # All access to voxel_positions will be done directly through the inner
        # class _VoxelPositions, so no need for a private property here
        self.voxel_positions = self._VoxelPositions(self._volume_limits, self._number_of_voxels)
        self._voxel_data = np.zeros(self._number_of_voxels, dtype = int)


    @property
    def number_of_voxels(self):
        return self._number_of_voxels


    @number_of_voxels.setter
    def number_of_voxels(self, number_of_voxels):
        # If `number_of_voxels` is not C-contiguous, create a C-contiguous copy
        self._number_of_voxels = np.asarray(number_of_voxels, dtype = int, order = &#34;C&#34;)
        # Check that number_of_voxels has shape(3,)
        if self._number_of_voxels.ndim != 1 or self._number_of_voxels.shape[0] != 3:
            raise ValueError(&#34;\n[ERROR]: number_of_voxels should have dimensions (3,). Received {}\n&#34;.format(self._number_of_voxels.shape))

        self._voxel_sizes = self._volume_limits / self._number_of_voxels

        # If, for dimension x, there are 5 voxels between coordinates 0
        # and 5, then the delimiting grid is [0, 1, 2, 3, 4, 5].
        self._voxel_grid = [np.linspace(0, self._volume_limits[i], self._number_of_voxels[i] + 1) for i in range(3)]

        # All access to voxel_positions will be done directly through the inner
        # class _VoxelPositions, so no need for a private property here
        self.voxel_positions = self._VoxelPositions(self._volume_limits, self._number_of_voxels)
        self._voxel_data = np.zeros(self._number_of_voxels, dtype = int)


    @property
    def voxel_sizes(self):
        return self._voxel_sizes


    @property
    def voxel_grid(self):
        return self._voxel_grid


    @property
    def voxel_data(self):
        return self._voxel_data


    def traverse_python(self, lor_indices = None):
        # Adapted from &#34;A Fast Voxel Traversal Algorithm for Ray Tracing&#34; by
        # John Amanatides and Andrew Woo.

        # Traverse voxels for all LoRs by default
        if lor_indices is None:
            lor_indices = range(self._number_of_lines)

        if not hasattr(lor_indices, &#34;__iter__&#34;):
            raise TypeError(&#34;[ERROR]: The `lor_indices` parameter must be iterable.&#34;)

        # The adapted grid traversal algorithm
        for li in lor_indices:
            # Define a line as L(t) = U + t V
            # If an LoR is defined as two points P1 and P2, then
            # U = P1 and V = P2 - P1
            p1 = self._line_data[li, 1:4]
            p2 = self._line_data[li, 4:7]
            u = p1
            v = p2 - p1

            ##############################################################
            # Initialisation stage

            # The step [sx, sy, sz] defines the sense of the LoR.
            # If V[0] is positive, then sx = 1
            # If V[0] is negative, then sx = -1
            step = np.array([1, 1, 1], dtype = int)
            for i, c in enumerate(v):
                if c &lt; 0:
                    step[i] = -1

            # The current voxel indices [ix, iy, iz] that the line passes
            # through.
            voxel_index = np.array([0, 0, 0], dtype = int)

            # The value of t at which the line passes through to the next
            # voxel, for each dimension.
            t_next = np.array([0., 0., 0.], dtype = float)

            # Find the initial voxel that the line starts from, for each
            # dimension.
            for i in range(len(voxel_index)):
                # If, for dimension x, there are 5 voxels between coordinates 0
                # and 5, then the delimiting grid is [0, 1, 2, 3, 4, 5].
                # If the line starts at 1.5, then it is part of the voxel at
                # index 1.
                voxel_index[i] = np.searchsorted(self._voxel_grid[i], u[i], side = &#34;right&#34;) - 1

                # If the line is going &#34;up&#34;, the next voxel is the next one
                if v[i] &gt;= 0:
                    offset = 1
                # If the line is going &#34;down&#34;, the next voxel is the current one
                else:
                    offset = 0
                t_next[i] = (self._voxel_grid[i][voxel_index[i] + offset] - u[i]) / v[i]

            # delta_t indicates how far along the ray we must move (in units of
            # t) for each component to be equal to the size of the voxel in
            # that dimension.
            delta_t = np.abs(self._voxel_sizes / v)

            ###############################################################
            # Incremental traversal stage

            # Loop until we reach the last voxel in space
            while (voxel_index &lt; self._number_of_voxels).all() and (voxel_index &gt;= 0).all():

                self._voxel_data[tuple(voxel_index)] += 1

                # If p2 is fully bounded by the voxel, stop the algorithm
                if ((self.voxel_positions._at_corner(voxel_index) &lt; p2).all() and
                    (self.voxel_positions._at_corner(voxel_index + 1) &gt; p2).all()):
                    break

                # The dimension of the minimum t that makes the line pass
                # through to the next voxel
                min_i = t_next.argmin()
                t_next[min_i] += delta_t[min_i]
                voxel_index[min_i] += step[min_i]


    def traverse(self, lor_indices = None):
        # Traverse all intersecting voxels for selected LoRs.

        # Traverse voxels for all LoRs by default
        if lor_indices is None:
            lor_indices = range(self._number_of_lines)

        if not hasattr(lor_indices, &#34;__iter__&#34;):
            raise TypeError(&#34;[ERROR]: The `lor_indices` parameter must be iterable.&#34;)

        traverse3d(
            self._voxel_data,
            self._line_data[lor_indices],
            self._voxel_grid[0],
            self._voxel_grid[1],
            self._voxel_grid[2]
        )


    def indices(self, coords):
        # Find the voxel indices for a point at `coords`
        coords = np.asarray(coords, dtype = float)
        if coords.ndim != 1 or coords.shape[0] != 3:
            raise ValueError(&#34;The `coords` parameter must have shape (3,). Received {}.&#34;.format(coords))

        indices = np.array([0, 0, 0], dtype = int)
        for i in range(3):
            indices[i] = np.searchsorted(self._voxel_grid[i], coords[i], side = &#34;right&#34;) - 1

        return indices


    def cube_trace(self, index, opacity = 0.4, color = None, colorscale = False):
        # For a small number of cubes

        index = np.asarray(index, dtype = int)
        xyz = self.voxel_positions.at_corner(*index)

        x = np.array([0, 0, 1, 1, 0, 0, 1, 1]) * self._voxel_sizes[0]
        y = np.array([0, 1, 1, 0, 0, 1, 1, 0]) * self._voxel_sizes[1]
        z = np.array([0, 0, 0, 0, 1, 1, 1, 1]) * self._voxel_sizes[2]
        i = np.array([7, 0, 0, 0, 4, 4, 6, 6, 4, 0, 3, 2])
        j = np.array([3, 4, 1, 2, 5, 6, 5, 2, 0, 1, 6, 3])
        k = np.array([0, 7, 2, 3, 6, 7, 1, 1, 5, 5, 7, 6])

        cube = dict(
            x =  x + xyz[0],
            y =  y + xyz[1],
            z =  z + xyz[2],
            i =  i,
            j =  j,
            k =  k,
            opacity = opacity,
            color = color
        )

        if colorscale:
            cmap = matplotlib.cm.get_cmap(&#34;magma&#34;)
            c = cmap(self._voxel_data[tuple(index)] / (self._voxel_data.max() or 1))
            cube.update(
                color = &#34;rgb({},{},{})&#34;.format(c[0], c[1], c[2])
            )

        return go.Mesh3d(cube)


    def cubes_traces(
        self,
        condition = lambda voxel_data: voxel_data &gt; 0,
        opacity = 0.4,
        color = None,
        colorscale = False
    ):
        # For a small number of cubes

        indices = np.argwhere(condition(self._voxel_data))
        traces = [self.cube_trace(i, opacity = opacity, color = color, colorscale = colorscale) for i in indices]

        return traces


    def voxels_trace(
        self,
        condition = lambda voxel_data: voxel_data &gt; 0,
        size = 4,
        opacity = 0.4,
        color = None,
        colorscale = False
    ):
        # For a large number of cubes

        filtered_indices = np.argwhere(condition(self._voxel_data))
        positions = self.voxel_positions._at(filtered_indices)

        marker = dict(
            size = size,
            color = color,
            symbol = &#34;square&#34;
        )

        if colorscale:
            cvalues = [self._voxel_data[tuple(t)] for t in filtered_indices]
            marker.update(colorscale = &#34;Magma&#34;, color = cvalues)

        voxels = dict(
            x = positions[:, 0],
            y = positions[:, 1],
            z = positions[:, 2],
            opacity = opacity,
            mode = &#34;markers&#34;,
            marker = marker
        )

        return go.Scatter3d(voxels)


    def heatmap_trace(
        self,
        ix = None,
        iy = None,
        iz = None,
        width = 0
    ):

        if ix is not None:
            x = self._voxel_grid[1]
            y = self._voxel_grid[2]
            z = self._voxel_data[ix, :, :]

            for i in range(1, width + 1):
                z = z + self._voxel_data[ix + i, :, :]
                z = z + self._voxel_data[ix - i, :, :]

        elif iy is not None:
            x = self._voxel_grid[0]
            y = self._voxel_grid[2]
            z = self._voxel_data[:, iy, :]

            for i in range(1, width + 1):
                z = z + self._voxel_data[:, iy + i, :]
                z = z + self._voxel_data[:, iy - i, :]

        elif iz is not None:
            x = self._voxel_grid[0]
            y = self._voxel_grid[1]
            z = self._voxel_data[:, :, iz]

            for i in range(1, width + 1):
                z = z + self._voxel_data[:, :, iz + i]
                z = z + self._voxel_data[:, :, iz - i]

        else:
            raise ValueError(&#34;[ERROR]: One of the `ix`, `iy`, `iz` slice indices must be provided.&#34;)

        heatmap = dict(
            x = x,
            y = y,
            z = z,
            colorscale = &#34;Magma&#34;,
            transpose = True
        )

        return go.Heatmap(heatmap)


    def __str__(self):
        # Shown when calling print(class)
        docstr = &#34;&#34;

        docstr += &#34;number_of_lines =   {}\n\n&#34;.format(self.number_of_lines)
        docstr += &#34;volume_limits =     {}\n&#34;.format(self.volume_limits)
        docstr += &#34;number_of_voxels =  {}\n&#34;.format(self.number_of_voxels)
        docstr += &#34;voxel_sizes =       {}\n\n&#34;.format(self.voxel_sizes)

        docstr += &#34;line_data = \n&#34;
        docstr += self._line_data.__str__()

        docstr += &#34;\n\nvoxel_data = \n&#34;
        docstr += self._voxel_data.__str__()

        return docstr


    def __repr__(self):
        # Shown when writing the class on a REPR

        docstr = &#34;Class instance that inherits from `pept.VoxelData`.\n\n&#34; + self.__str__() + &#34;\n\n&#34;

        return docstr</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pept.base.voxel_data.VoxelData.line_data"><code class="name">var <span class="ident">line_data</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def line_data(self):
    return self._line_data</code></pre>
</details>
</dd>
<dt id="pept.base.voxel_data.VoxelData.number_of_lines"><code class="name">var <span class="ident">number_of_lines</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def number_of_lines(self):
    return self._number_of_lines</code></pre>
</details>
</dd>
<dt id="pept.base.voxel_data.VoxelData.number_of_voxels"><code class="name">var <span class="ident">number_of_voxels</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def number_of_voxels(self):
    return self._number_of_voxels</code></pre>
</details>
</dd>
<dt id="pept.base.voxel_data.VoxelData.volume_limits"><code class="name">var <span class="ident">volume_limits</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def volume_limits(self):
    return self._volume_limits</code></pre>
</details>
</dd>
<dt id="pept.base.voxel_data.VoxelData.voxel_data"><code class="name">var <span class="ident">voxel_data</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def voxel_data(self):
    return self._voxel_data</code></pre>
</details>
</dd>
<dt id="pept.base.voxel_data.VoxelData.voxel_grid"><code class="name">var <span class="ident">voxel_grid</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def voxel_grid(self):
    return self._voxel_grid</code></pre>
</details>
</dd>
<dt id="pept.base.voxel_data.VoxelData.voxel_sizes"><code class="name">var <span class="ident">voxel_sizes</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def voxel_sizes(self):
    return self._voxel_sizes</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pept.base.voxel_data.VoxelData.cube_trace"><code class="name flex">
<span>def <span class="ident">cube_trace</span></span>(<span>self, index, opacity=0.4, color=None, colorscale=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def cube_trace(self, index, opacity = 0.4, color = None, colorscale = False):
    # For a small number of cubes

    index = np.asarray(index, dtype = int)
    xyz = self.voxel_positions.at_corner(*index)

    x = np.array([0, 0, 1, 1, 0, 0, 1, 1]) * self._voxel_sizes[0]
    y = np.array([0, 1, 1, 0, 0, 1, 1, 0]) * self._voxel_sizes[1]
    z = np.array([0, 0, 0, 0, 1, 1, 1, 1]) * self._voxel_sizes[2]
    i = np.array([7, 0, 0, 0, 4, 4, 6, 6, 4, 0, 3, 2])
    j = np.array([3, 4, 1, 2, 5, 6, 5, 2, 0, 1, 6, 3])
    k = np.array([0, 7, 2, 3, 6, 7, 1, 1, 5, 5, 7, 6])

    cube = dict(
        x =  x + xyz[0],
        y =  y + xyz[1],
        z =  z + xyz[2],
        i =  i,
        j =  j,
        k =  k,
        opacity = opacity,
        color = color
    )

    if colorscale:
        cmap = matplotlib.cm.get_cmap(&#34;magma&#34;)
        c = cmap(self._voxel_data[tuple(index)] / (self._voxel_data.max() or 1))
        cube.update(
            color = &#34;rgb({},{},{})&#34;.format(c[0], c[1], c[2])
        )

    return go.Mesh3d(cube)</code></pre>
</details>
</dd>
<dt id="pept.base.voxel_data.VoxelData.cubes_traces"><code class="name flex">
<span>def <span class="ident">cubes_traces</span></span>(<span>self, condition=<function VoxelData.<lambda> at 0x11815e560>, opacity=0.4, color=None, colorscale=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def cubes_traces(
    self,
    condition = lambda voxel_data: voxel_data &gt; 0,
    opacity = 0.4,
    color = None,
    colorscale = False
):
    # For a small number of cubes

    indices = np.argwhere(condition(self._voxel_data))
    traces = [self.cube_trace(i, opacity = opacity, color = color, colorscale = colorscale) for i in indices]

    return traces</code></pre>
</details>
</dd>
<dt id="pept.base.voxel_data.VoxelData.heatmap_trace"><code class="name flex">
<span>def <span class="ident">heatmap_trace</span></span>(<span>self, ix=None, iy=None, iz=None, width=0)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def heatmap_trace(
    self,
    ix = None,
    iy = None,
    iz = None,
    width = 0
):

    if ix is not None:
        x = self._voxel_grid[1]
        y = self._voxel_grid[2]
        z = self._voxel_data[ix, :, :]

        for i in range(1, width + 1):
            z = z + self._voxel_data[ix + i, :, :]
            z = z + self._voxel_data[ix - i, :, :]

    elif iy is not None:
        x = self._voxel_grid[0]
        y = self._voxel_grid[2]
        z = self._voxel_data[:, iy, :]

        for i in range(1, width + 1):
            z = z + self._voxel_data[:, iy + i, :]
            z = z + self._voxel_data[:, iy - i, :]

    elif iz is not None:
        x = self._voxel_grid[0]
        y = self._voxel_grid[1]
        z = self._voxel_data[:, :, iz]

        for i in range(1, width + 1):
            z = z + self._voxel_data[:, :, iz + i]
            z = z + self._voxel_data[:, :, iz - i]

    else:
        raise ValueError(&#34;[ERROR]: One of the `ix`, `iy`, `iz` slice indices must be provided.&#34;)

    heatmap = dict(
        x = x,
        y = y,
        z = z,
        colorscale = &#34;Magma&#34;,
        transpose = True
    )

    return go.Heatmap(heatmap)</code></pre>
</details>
</dd>
<dt id="pept.base.voxel_data.VoxelData.indices"><code class="name flex">
<span>def <span class="ident">indices</span></span>(<span>self, coords)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def indices(self, coords):
    # Find the voxel indices for a point at `coords`
    coords = np.asarray(coords, dtype = float)
    if coords.ndim != 1 or coords.shape[0] != 3:
        raise ValueError(&#34;The `coords` parameter must have shape (3,). Received {}.&#34;.format(coords))

    indices = np.array([0, 0, 0], dtype = int)
    for i in range(3):
        indices[i] = np.searchsorted(self._voxel_grid[i], coords[i], side = &#34;right&#34;) - 1

    return indices</code></pre>
</details>
</dd>
<dt id="pept.base.voxel_data.VoxelData.traverse"><code class="name flex">
<span>def <span class="ident">traverse</span></span>(<span>self, lor_indices=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def traverse(self, lor_indices = None):
    # Traverse all intersecting voxels for selected LoRs.

    # Traverse voxels for all LoRs by default
    if lor_indices is None:
        lor_indices = range(self._number_of_lines)

    if not hasattr(lor_indices, &#34;__iter__&#34;):
        raise TypeError(&#34;[ERROR]: The `lor_indices` parameter must be iterable.&#34;)

    traverse3d(
        self._voxel_data,
        self._line_data[lor_indices],
        self._voxel_grid[0],
        self._voxel_grid[1],
        self._voxel_grid[2]
    )</code></pre>
</details>
</dd>
<dt id="pept.base.voxel_data.VoxelData.traverse_python"><code class="name flex">
<span>def <span class="ident">traverse_python</span></span>(<span>self, lor_indices=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def traverse_python(self, lor_indices = None):
    # Adapted from &#34;A Fast Voxel Traversal Algorithm for Ray Tracing&#34; by
    # John Amanatides and Andrew Woo.

    # Traverse voxels for all LoRs by default
    if lor_indices is None:
        lor_indices = range(self._number_of_lines)

    if not hasattr(lor_indices, &#34;__iter__&#34;):
        raise TypeError(&#34;[ERROR]: The `lor_indices` parameter must be iterable.&#34;)

    # The adapted grid traversal algorithm
    for li in lor_indices:
        # Define a line as L(t) = U + t V
        # If an LoR is defined as two points P1 and P2, then
        # U = P1 and V = P2 - P1
        p1 = self._line_data[li, 1:4]
        p2 = self._line_data[li, 4:7]
        u = p1
        v = p2 - p1

        ##############################################################
        # Initialisation stage

        # The step [sx, sy, sz] defines the sense of the LoR.
        # If V[0] is positive, then sx = 1
        # If V[0] is negative, then sx = -1
        step = np.array([1, 1, 1], dtype = int)
        for i, c in enumerate(v):
            if c &lt; 0:
                step[i] = -1

        # The current voxel indices [ix, iy, iz] that the line passes
        # through.
        voxel_index = np.array([0, 0, 0], dtype = int)

        # The value of t at which the line passes through to the next
        # voxel, for each dimension.
        t_next = np.array([0., 0., 0.], dtype = float)

        # Find the initial voxel that the line starts from, for each
        # dimension.
        for i in range(len(voxel_index)):
            # If, for dimension x, there are 5 voxels between coordinates 0
            # and 5, then the delimiting grid is [0, 1, 2, 3, 4, 5].
            # If the line starts at 1.5, then it is part of the voxel at
            # index 1.
            voxel_index[i] = np.searchsorted(self._voxel_grid[i], u[i], side = &#34;right&#34;) - 1

            # If the line is going &#34;up&#34;, the next voxel is the next one
            if v[i] &gt;= 0:
                offset = 1
            # If the line is going &#34;down&#34;, the next voxel is the current one
            else:
                offset = 0
            t_next[i] = (self._voxel_grid[i][voxel_index[i] + offset] - u[i]) / v[i]

        # delta_t indicates how far along the ray we must move (in units of
        # t) for each component to be equal to the size of the voxel in
        # that dimension.
        delta_t = np.abs(self._voxel_sizes / v)

        ###############################################################
        # Incremental traversal stage

        # Loop until we reach the last voxel in space
        while (voxel_index &lt; self._number_of_voxels).all() and (voxel_index &gt;= 0).all():

            self._voxel_data[tuple(voxel_index)] += 1

            # If p2 is fully bounded by the voxel, stop the algorithm
            if ((self.voxel_positions._at_corner(voxel_index) &lt; p2).all() and
                (self.voxel_positions._at_corner(voxel_index + 1) &gt; p2).all()):
                break

            # The dimension of the minimum t that makes the line pass
            # through to the next voxel
            min_i = t_next.argmin()
            t_next[min_i] += delta_t[min_i]
            voxel_index[min_i] += step[min_i]</code></pre>
</details>
</dd>
<dt id="pept.base.voxel_data.VoxelData.voxels_trace"><code class="name flex">
<span>def <span class="ident">voxels_trace</span></span>(<span>self, condition=<function VoxelData.<lambda> at 0x11815e680>, size=4, opacity=0.4, color=None, colorscale=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def voxels_trace(
    self,
    condition = lambda voxel_data: voxel_data &gt; 0,
    size = 4,
    opacity = 0.4,
    color = None,
    colorscale = False
):
    # For a large number of cubes

    filtered_indices = np.argwhere(condition(self._voxel_data))
    positions = self.voxel_positions._at(filtered_indices)

    marker = dict(
        size = size,
        color = color,
        symbol = &#34;square&#34;
    )

    if colorscale:
        cvalues = [self._voxel_data[tuple(t)] for t in filtered_indices]
        marker.update(colorscale = &#34;Magma&#34;, color = cvalues)

    voxels = dict(
        x = positions[:, 0],
        y = positions[:, 1],
        z = positions[:, 2],
        opacity = opacity,
        mode = &#34;markers&#34;,
        marker = marker
    )

    return go.Scatter3d(voxels)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pept.base" href="index.html">pept.base</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pept.base.voxel_data.VoxelData" href="#pept.base.voxel_data.VoxelData">VoxelData</a></code></h4>
<ul class="two-column">
<li><code><a title="pept.base.voxel_data.VoxelData.cube_trace" href="#pept.base.voxel_data.VoxelData.cube_trace">cube_trace</a></code></li>
<li><code><a title="pept.base.voxel_data.VoxelData.cubes_traces" href="#pept.base.voxel_data.VoxelData.cubes_traces">cubes_traces</a></code></li>
<li><code><a title="pept.base.voxel_data.VoxelData.heatmap_trace" href="#pept.base.voxel_data.VoxelData.heatmap_trace">heatmap_trace</a></code></li>
<li><code><a title="pept.base.voxel_data.VoxelData.indices" href="#pept.base.voxel_data.VoxelData.indices">indices</a></code></li>
<li><code><a title="pept.base.voxel_data.VoxelData.line_data" href="#pept.base.voxel_data.VoxelData.line_data">line_data</a></code></li>
<li><code><a title="pept.base.voxel_data.VoxelData.number_of_lines" href="#pept.base.voxel_data.VoxelData.number_of_lines">number_of_lines</a></code></li>
<li><code><a title="pept.base.voxel_data.VoxelData.number_of_voxels" href="#pept.base.voxel_data.VoxelData.number_of_voxels">number_of_voxels</a></code></li>
<li><code><a title="pept.base.voxel_data.VoxelData.traverse" href="#pept.base.voxel_data.VoxelData.traverse">traverse</a></code></li>
<li><code><a title="pept.base.voxel_data.VoxelData.traverse_python" href="#pept.base.voxel_data.VoxelData.traverse_python">traverse_python</a></code></li>
<li><code><a title="pept.base.voxel_data.VoxelData.volume_limits" href="#pept.base.voxel_data.VoxelData.volume_limits">volume_limits</a></code></li>
<li><code><a title="pept.base.voxel_data.VoxelData.voxel_data" href="#pept.base.voxel_data.VoxelData.voxel_data">voxel_data</a></code></li>
<li><code><a title="pept.base.voxel_data.VoxelData.voxel_grid" href="#pept.base.voxel_data.VoxelData.voxel_grid">voxel_grid</a></code></li>
<li><code><a title="pept.base.voxel_data.VoxelData.voxel_sizes" href="#pept.base.voxel_data.VoxelData.voxel_sizes">voxel_sizes</a></code></li>
<li><code><a title="pept.base.voxel_data.VoxelData.voxels_trace" href="#pept.base.voxel_data.VoxelData.voxels_trace">voxels_trace</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>