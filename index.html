<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.3" />
<title>pept API documentation</title>
<meta name="description" content="![version](https://img.shields.io/badge/version-0.1.4-blue)
[![Open In …" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pept</code></h1>
</header>
<section id="section-intro">
<p><img alt="version" src="https://img.shields.io/badge/version-0.1.4-blue">
<a href="https://colab.research.google.com/drive/1G8XHP9zWMMDVu23PXzANLCOKNP_RjBEO"><img alt="Open In Colab" src="https://colab.research.google.com/assets/colab-badge.svg"></a>
<a href="https://uob-positron-imaging-centre.github.io"><img alt="" src="https://img.shields.io/badge/-docs-success"></a></p>
<h1 id="pept">PEPT</h1>
<p>A Python library that integrates all the tools necessary to
perform research using Positron Emission Particle Tracking (PEPT). The library
includes algorithms for the location, identification and tracking of particles,
in addition to tools for visualisation and analysis, and utilities allowing the
realistic simulation of PEPT data.</p>
<h2 id="positron-emission-particle-tracking">Positron Emission Particle Tracking</h2>
<p>PEPT is a technique developed at the University of Birmingham which allows the
non-invasive, three-dimensional tracking of one or more 'tracer' particles through
particulate, fluid or multiphase systems. The technique allows particle or fluid
motion to be tracked with sub-millimetre accuracy and sub-millisecond temporal
resolution and, due to its use of highly-penetrating 511keV gamma rays, can be
used to probe the internal dynamics of even large, dense, optically opaque
systems - making it ideal for industrial as well as scientific applications.</p>
<h2 id="getting-started">Getting Started</h2>
<p>These instructions will help you get started with PEPT data analysis.</p>
<h3 id="prerequisites">Prerequisites</h3>
<p>This package supports Python 3. You also need to have <code>NumPy</code> and <code>Cython</code>
on your system in order to install it.</p>
<h3 id="installation">Installation</h3>
<p>You can install <a title="pept" href="#pept"><code>pept</code></a> from PyPI:</p>
<pre><code>pip install pept
</code></pre>
<p>Or you can install the latest version from the GitHub repository:</p>
<pre><code>pip install git+&lt;https://github.com/uob-positron-imaging-centre/pept&gt;
</code></pre>
<h3 id="example-usage">Example usage</h3>
<p>You can download data samples from the <a href="https://github.com/uob-positron-imaging-centre/example_data">UoB Positron Imaging Centre's
Repository</a>:</p>
<pre><code>$&gt; git clone &lt;https://github.com/uob-positron-imaging-centre/example_data&gt;
</code></pre>
<p>A minimal analysis script using the <code>pept.tracking.peptml</code> subpackage:</p>
<pre><code>import pept
from pept.scanners import ParallelScreens
from pept.tracking import peptml
from pept.visualisation import PlotlyGrapher

lors = ParallelScreens('example_data/sample_2p_42rpm.csv', skiprows = 16)

max_distance = 0.1
cutpoints = peptml.Cutpoints(lors, max_distance)

clusterer = peptml.HDBSCANClusterer(min_sample_size = 30)
centres, clustered_cutpoints = clusterer.fit_cutpoints(cutpoints)

fig = PlotlyGrapher().create_figure()
fig.add_trace(centres.points_trace())
fig.show()
</code></pre>
<p>A more in-depth tutorial is available on <a href="https://colab.research.google.com/drive/1G8XHP9zWMMDVu23PXzANLCOKNP_RjBEO">Google
Colab</a>.</p>
<p>Full documentation is available <a href="https://uob-positron-imaging-centre.github.io">here</a>.</p>
<h2 id="performance">Performance</h2>
<p>Significant effort has been put into making the algorithms in this package as
fast as possible. The most compute-intensive parts have been implemented in
<code>C</code> and parallelised, where possible, using <code>joblib</code>. For example, using the <code>peptml</code>
subpackage, analysing 1,000,000 LoRs on the author's machine (mid 2012 MacBook Pro)
takes ~26 s (with another 12 s to read in the data). This efficiency is largely
due to the availabiliy of a great high-performance <a href="https://github.com/scikit-learn-contrib/hdbscan">implementation of the
HDBSCAN</a> clustering algorithm.</p>
<h2 id="help-and-support">Help and Support</h2>
<p>We recommend you check out <a href="https://colab.research.google.com/drive/1G8XHP9zWMMDVu23PXzANLCOKNP_RjBEO">our tutorials</a>. If your issue is not suitably resolved there, please
check the <a href="https://github.com/uob-positron-imaging-centre/pept/issues">issues</a>
page on our GitHub. Finally, if no solution is available there, feel free to
<a href="https://github.com/uob-positron-imaging-centre/pept/issues/new">open an
issue</a>; the
authors will attempt to respond in a reasonably timely fashion.</p>
<h2 id="contributing">Contributing</h2>
<p>We welcome contributions in any form! Assistance with documentation, particularly
expanding tutorials, is always welcome. To contribute please fork the project, make
your changes and submit a pull request. We will do our best to work through any
issues with you and get your code merged into the main branch.</p>
<h2 id="citing">Citing</h2>
<p>If you used this codebase or any software making use of it in a scientific
publication, you must cite the following paper:</p>
<blockquote>
<p>Nicuşan AL, Windows-Yule CR. Positron emission particle tracking using machine learning. Review of Scientific Instruments. 2020 Jan 1;91(1):013329.</p>
<p><a href="https://doi.org/10.1063/1.5129251">https://doi.org/10.1063/1.5129251</a></p>
</blockquote>
<h2 id="licensing">Licensing</h2>
<p>The <code>pept</code> package is GNU v3.0 licensed.
Copyright (C) 2020 Andrei Leonard Nicusan.</p>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# File   : __init__.py
# License: License: GNU v3.0
# Author : Andrei Leonard Nicusan &lt;a.l.nicusan@bham.ac.uk&gt;
# Date   : 19.08.2019


&#39;&#39;&#39;

![version](https://img.shields.io/badge/version-0.1.4-blue)
[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/drive/1G8XHP9zWMMDVu23PXzANLCOKNP_RjBEO)
[![](https://img.shields.io/badge/-docs-success)](https://uob-positron-imaging-centre.github.io)

# PEPT


A Python library that integrates all the tools necessary to
perform research using Positron Emission Particle Tracking (PEPT). The library
includes algorithms for the location, identification and tracking of particles,
in addition to tools for visualisation and analysis, and utilities allowing the
realistic simulation of PEPT data.


## Positron Emission Particle Tracking
PEPT is a technique developed at the University of Birmingham which allows the
non-invasive, three-dimensional tracking of one or more &#39;tracer&#39; particles through
particulate, fluid or multiphase systems. The technique allows particle or fluid
motion to be tracked with sub-millimetre accuracy and sub-millisecond temporal
resolution and, due to its use of highly-penetrating 511keV gamma rays, can be
used to probe the internal dynamics of even large, dense, optically opaque
systems - making it ideal for industrial as well as scientific applications.


## Getting Started

These instructions will help you get started with PEPT data analysis.

### Prerequisites

This package supports Python 3. You also need to have `NumPy` and `Cython`
on your system in order to install it.

### Installation

You can install `pept` from PyPI:

```
pip install pept
```

Or you can install the latest version from the GitHub repository:

```
pip install git+https://github.com/uob-positron-imaging-centre/pept
```

### Example usage

You can download data samples from the [UoB Positron Imaging Centre&#39;s
Repository](https://github.com/uob-positron-imaging-centre/example_data):

```
$&gt; git clone https://github.com/uob-positron-imaging-centre/example_data
```

A minimal analysis script using the `pept.tracking.peptml` subpackage:

```
import pept
from pept.scanners import ParallelScreens
from pept.tracking import peptml
from pept.visualisation import PlotlyGrapher

lors = ParallelScreens(&#39;example_data/sample_2p_42rpm.csv&#39;, skiprows = 16)

max_distance = 0.1
cutpoints = peptml.Cutpoints(lors, max_distance)

clusterer = peptml.HDBSCANClusterer(min_sample_size = 30)
centres, clustered_cutpoints = clusterer.fit_cutpoints(cutpoints)

fig = PlotlyGrapher().create_figure()
fig.add_trace(centres.points_trace())
fig.show()
```

A more in-depth tutorial is available on [Google
Colab](https://colab.research.google.com/drive/1G8XHP9zWMMDVu23PXzANLCOKNP_RjBEO).

Full documentation is available [here](https://uob-positron-imaging-centre.github.io).


## Performance

Significant effort has been put into making the algorithms in this package as
fast as possible. The most compute-intensive parts have been implemented in
`C` and parallelised, where possible, using `joblib`. For example, using the `peptml`
subpackage, analysing 1,000,000 LoRs on the author&#39;s machine (mid 2012 MacBook Pro)
takes ~26 s (with another 12 s to read in the data). This efficiency is largely
due to the availabiliy of a great high-performance [implementation of the
HDBSCAN](https://github.com/scikit-learn-contrib/hdbscan) clustering algorithm.


## Help and Support

We recommend you check out [our tutorials](https://colab.research.google.com/drive/1G8XHP9zWMMDVu23PXzANLCOKNP_RjBEO). If your issue is not suitably resolved there, please
check the [issues](https://github.com/uob-positron-imaging-centre/pept/issues)
page on our GitHub. Finally, if no solution is available there, feel free to
[open an
issue](https://github.com/uob-positron-imaging-centre/pept/issues/new); the
authors will attempt to respond in a reasonably timely fashion.

## Contributing

We welcome contributions in any form! Assistance with documentation, particularly
expanding tutorials, is always welcome. To contribute please fork the project, make
your changes and submit a pull request. We will do our best to work through any
issues with you and get your code merged into the main branch.

## Citing

If you used this codebase or any software making use of it in a scientific
publication, you must cite the following paper:

&gt; Nicuşan AL, Windows-Yule CR. Positron emission particle tracking using machine learning. Review of Scientific Instruments. 2020 Jan 1;91(1):013329.

&gt; https://doi.org/10.1063/1.5129251

## Licensing

The `pept` package is GNU v3.0 licensed.
Copyright (C) 2020 Andrei Leonard Nicusan.


&#39;&#39;&#39;


# Import base data structures
from    .base.line_data     import  LineData
from    .base.point_data    import  PointData
from    .base.voxel_data    import  VoxelData

# Import subpackages
from    .                   import  scanners
from    .                   import  simulation
from    .                   import  diagnostics
from    .                   import  tracking
from    .                   import  visualisation
from    .                   import  utilities

# Import package version
from    .__version__        import  __version__


__all__ = [
    &#39;LineData&#39;,
    &#39;PointData&#39;,
    &#39;VoxelData&#39;,
    &#39;scanners&#39;,
    &#39;simulation&#39;,
    &#39;diagnostics&#39;,
    &#39;tracking&#39;,
    &#39;visualisation&#39;,
    &#39;utilities&#39;
]


__author__ =        &#34;Andrei Leonard Nicusan&#34;
__credits__ =       [&#34;Andrei Leonard Nicusan&#34;, &#34;Kit Windows-Yule&#34;, &#34;Sam Manger&#34;]
__license__ =       &#34;GNU v3.0&#34;
__maintainer__ =    &#34;Andrei Leonard Nicusan&#34;
__email__ =         &#34;a.l.nicusan@bham.ac.uk&#34;
__status__ =        &#34;Development&#34;</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="pept.base" href="base/index.html">pept.base</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="pept.diagnostics" href="diagnostics/index.html">pept.diagnostics</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="pept.scanners" href="scanners/index.html">pept.scanners</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="pept.simulation" href="simulation/index.html">pept.simulation</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="pept.tests" href="tests/index.html">pept.tests</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="pept.tracking" href="tracking/index.html">pept.tracking</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="pept.utilities" href="utilities/index.html">pept.utilities</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="pept.visualisation" href="visualisation/index.html">pept.visualisation</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pept.LineData"><code class="flex name class">
<span>class <span class="ident">LineData</span></span>
<span>(</span><span>line_data, sample_size=200, overlap=0, verbose=False)</span>
</code></dt>
<dd>
<section class="desc"><p>A class for PEPT LoR data iteration, manipulation and visualisation.</p>
<p>Generally, PEPT LoRs are lines in 3D space, each defined by two points,
irrespective of the geometry of the scanner used. This class is used
for LoRs (or any lines!) encapsulation. It can yield samples of the
<code>line_data</code> of an adaptive <code>sample_size</code> and <code>overlap</code>, without requiring
additional storage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>line_data</code></strong> :&ensp;(<code>N</code>, <code>7</code>) <code>numpy.ndarray</code></dt>
<dd>An (N, 7) numpy array that stores the PEPT LoRs (or any generic set of
lines) as time and cartesian (3D) coordinates of two points defining each
line, <strong>in mm</strong>. A row is then [time, x1, y1, z1, x2, y2, z2].</dd>
<dt><strong><code>sample_size</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>An <code>int`` that defines the number of lines that should be
returned when iterating over</code>line_data<code>. A</code>sample_size` of 0
yields all the data as one single sample. (Default is 200)</dd>
<dt><strong><code>overlap</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>An <code>int</code> that defines the overlap between two consecutive
samples that are returned when iterating over <code>line_data</code>.
An overlap of 0 means consecutive samples, while an overlap
of (<code>sample_size</code> - 1) means incrementing the samples by one.
A negative overlap means skipping values between samples. An
error is raised if <code>overlap</code> is larger than or equal to
<code>sample_size</code>. (Default is 0)</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>An option that enables printing the time taken for the
initialisation of an instance of the class. Useful when
reading large files (10gb files for PEPT data is not unheard
of). (Default is True)</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>line_data</code></strong> :&ensp;(<code>N</code>, <code>7</code>) <code>numpy.ndarray</code></dt>
<dd>An (N, 7) numpy array that stores the PEPT LoRs as time and
cartesian (3D) coordinates of two points defining a line, <strong>in mm</strong>.
Each row is then <code>[time, x1, y1, z1, x2, y2, z2]</code>.</dd>
<dt><strong><code>sample_size</code></strong> :&ensp;<code>int</code></dt>
<dd>An <code>int</code> that defines the number of lines that should be
returned when iterating over <code>line_data</code>. (Default is 200)</dd>
<dt><strong><code>overlap</code></strong> :&ensp;<code>int</code></dt>
<dd>An <code>int</code> that defines the overlap between two consecutive
samples that are returned when iterating over <code>line_data</code>.
An overlap of 0 means consecutive samples, while an overlap
of (<code>sample_size</code> - 1) means incrementing the samples by one.
A negative overlap means skipping values between samples. It
is required to be smaller than <code>sample_size</code>. (Default is 0)</dd>
<dt><strong><code>number_of_lines</code></strong> :&ensp;<code>int</code></dt>
<dd>An <code>int</code> that corresponds to len(<code>line_data</code>), or the number of
LoRs stored by <code>line_data</code>.</dd>
<dt><strong><code>number_of_samples</code></strong> :&ensp;<code>int</code></dt>
<dd>An <code>int</code> that corresponds to the number of samples that can be
accessed from the class. It takes <code>overlap</code> into consideration.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If <code>overlap</code> &gt;= <code>sample_size</code> unless <code>sample_size</code> is 0. Overlap
has to be smaller than <code>sample_size</code>. Note that it can also be negative.</dd>
<dt><code>ValueError</code></dt>
<dd>If <code>line_data</code> does not have (N, 7) shape.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The class saves <code>line_data</code> as a <strong>contiguous</strong> numpy array for
efficient access in C functions. It should not be changed after
instantiating the class.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class LineData:
    &#39;&#39;&#39;A class for PEPT LoR data iteration, manipulation and visualisation.

    Generally, PEPT LoRs are lines in 3D space, each defined by two points,
    irrespective of the geometry of the scanner used. This class is used
    for LoRs (or any lines!) encapsulation. It can yield samples of the
    `line_data` of an adaptive `sample_size` and `overlap`, without requiring
    additional storage.

    Parameters
    ----------
    line_data : (N, 7) numpy.ndarray
        An (N, 7) numpy array that stores the PEPT LoRs (or any generic set of
        lines) as time and cartesian (3D) coordinates of two points defining each
        line, **in mm**. A row is then [time, x1, y1, z1, x2, y2, z2].
    sample_size : int, optional
        An `int`` that defines the number of lines that should be
        returned when iterating over `line_data`. A `sample_size` of 0
        yields all the data as one single sample. (Default is 200)
    overlap : int, optional
        An `int` that defines the overlap between two consecutive
        samples that are returned when iterating over `line_data`.
        An overlap of 0 means consecutive samples, while an overlap
        of (`sample_size` - 1) means incrementing the samples by one.
        A negative overlap means skipping values between samples. An
        error is raised if `overlap` is larger than or equal to
        `sample_size`. (Default is 0)
    verbose : bool, optional
        An option that enables printing the time taken for the
        initialisation of an instance of the class. Useful when
        reading large files (10gb files for PEPT data is not unheard
        of). (Default is True)

    Attributes
    ----------
    line_data : (N, 7) numpy.ndarray
        An (N, 7) numpy array that stores the PEPT LoRs as time and
        cartesian (3D) coordinates of two points defining a line, **in mm**.
        Each row is then `[time, x1, y1, z1, x2, y2, z2]`.
    sample_size : int
        An `int` that defines the number of lines that should be
        returned when iterating over `line_data`. (Default is 200)
    overlap : int
        An `int` that defines the overlap between two consecutive
        samples that are returned when iterating over `line_data`.
        An overlap of 0 means consecutive samples, while an overlap
        of (`sample_size` - 1) means incrementing the samples by one.
        A negative overlap means skipping values between samples. It
        is required to be smaller than `sample_size`. (Default is 0)
    number_of_lines : int
        An `int` that corresponds to len(`line_data`), or the number of
        LoRs stored by `line_data`.
    number_of_samples : int
        An `int` that corresponds to the number of samples that can be
        accessed from the class. It takes `overlap` into consideration.

    Raises
    ------
    ValueError
        If `overlap` &gt;= `sample_size` unless `sample_size` is 0. Overlap
        has to be smaller than `sample_size`. Note that it can also be negative.
    ValueError
        If `line_data` does not have (N, 7) shape.

    Notes
    -----
    The class saves `line_data` as a **contiguous** numpy array for
    efficient access in C functions. It should not be changed after
    instantiating the class.

    &#39;&#39;&#39;

    def __init__(
        self,
        line_data,
        sample_size = 200,
        overlap = 0,
        verbose = False
    ):

        if verbose:
            start = time.time()

        # If sample_size != 0 (in which case the class returns all data in one
        # sample), check the `overlap` is not larger or equal to `sample_size`.
        if sample_size &lt; 0:
            raise ValueError(&#39;\n[ERROR]: sample_size = {} must be positive (&gt;= 0)&#39;.format(sample_size))
        if sample_size != 0 and overlap &gt;= sample_size:
            raise ValueError(&#39;\n[ERROR]: overlap = {} must be smaller than sample_size = {}\n&#39;.format(overlap, sample_size))

        # Initialise the inner parameters of the class
        self._index = 0
        self._sample_size = sample_size
        self._overlap = overlap

        # If `line_data` is not C-contiguous, create a C-contiguous copy
        self._line_data = np.asarray(line_data, order = &#39;C&#39;, dtype = float)

        # Check that line_data has shape (N, 7)
        if self._line_data.ndim != 2 or self._line_data.shape[1] != 7:
            raise ValueError(&#39;\n[ERROR]: line_data should have dimensions (N, 7). Received {}\n&#39;.format(self._line_data.shape))

        self._number_of_lines = len(self._line_data)

        if verbose:
            end = time.time()
            print(&#34;Initialising the PEPT data took {} seconds\n&#34;.format(end - start))


    @property
    def line_data(self):
        &#39;&#39;&#39;Get the lines stored in the class.

        Returns
        -------
        (, 7) numpy.ndarray
            A memory view of the lines stored in `line_data`.

        &#39;&#39;&#39;

        return self._line_data


    @property
    def sample_size(self):
        &#39;&#39;&#39;Get the number of lines in one sample returned by the class.

        Returns
        -------
        int
            The sample size (number of lines) in one sample returned by
            the class.

        &#39;&#39;&#39;

        return self._sample_size


    @sample_size.setter
    def sample_size(self, new_sample_size):
        &#39;&#39;&#39;Change `sample_size` without instantiating a new object

        It also resets the inner index of the class.

        Parameters
        ----------
        new_sample_size : int
            The new sample size. It has to be larger than `overlap`,
            unless it is 0 (in which case all `line_data` will be returned
            as one sample).

        Raises
        ------
        ValueError
            If `overlap` &gt;= `new_sample_size`. Overlap has to be
            smaller than `sample_size`, unless `sample_size` is 0.
            Note that it can also be negative.

        &#39;&#39;&#39;

        if new_sample_size &lt; 0:
            raise ValueError(&#39;\n[ERROR]: sample_size = {} must be positive (&gt;= 0)&#39;.format(new_sample_size))
        if new_sample_size != 0 and self._overlap &gt;= new_sample_size:
            raise ValueError(&#39;\n[ERROR]: overlap = {} must be smaller than new_sample_size = {}\n&#39;.format(self._overlap, new_sample_size))

        self._index = 0
        self._sample_size = new_sample_size


    @property
    def overlap(self):
        &#39;&#39;&#39;Get the overlap between every two samples returned by the class.

        Returns
        -------
        int
            The overlap (number of lines) between every two samples  returned by
            the class.

        &#39;&#39;&#39;

        return self._overlap


    @overlap.setter
    def overlap(self, new_overlap):
        &#39;&#39;&#39;Change `overlap` without instantiating a new object

        It also resets the inner index of the class.

        Parameters
        ----------
        new_overlap : int
            The new overlap. It has to be smaller than `sample_size`, unless
            `sample_size` is 0 (in which case all `line_data` will be returned
            as one sample and so overlap does not play any role).

        Raises
        ------
        ValueError
            If `new_overlap` &gt;= `sample_size`. `new_overlap` has to be
            smaller than `sample_size`, unless `sample_size` is 0.
            Note that it can also be negative.

        &#39;&#39;&#39;

        if self._sample_size != 0 and new_overlap &gt;= self._sample_size:
            raise ValueError(&#39;\n[ERROR]: new_overlap = {} must be smaller than sample_size = {}\n&#39;.format(new_overlap, self._sample_size))

        self._index = 0
        self._overlap = new_overlap


    @property
    def number_of_samples(self):
        &#39;&#39;&#39;Get number of samples, considering overlap.

        If `sample_size == 0`, all data is returned as a single sample,
        and so `number_of_samples` will be 1. Otherwise, it checks the
        number of samples every time it is called, taking `overlap` into
        consideration.

        Returns
        -------
        int
            The number of samples, taking `overlap` into consideration.

        &#39;&#39;&#39;
        # If self.sample_size == 0, all data is returned as a single sample
        if self._sample_size == 0:
            return 1

        # If self.sample_size != 0, check there is at least one sample
        if self._number_of_lines &gt;= self._sample_size:
            return (self._number_of_lines - self._sample_size) // (self.sample_size - self.overlap) + 1
        else:
            return 0


    @property
    def number_of_lines(self):
        &#39;&#39;&#39;Get the number of lines stored in the class.

        Returns
        -------
        int
            The number of lines stored in `line_data`.

        &#39;&#39;&#39;
        return self._number_of_lines


    def sample_n(self, n):
        &#39;&#39;&#39;Get sample number n (indexed from 1, i.e. `n &gt; 0`)

        Returns the lines from `line_data` included in sample number
        `n`. Samples are numbered starting from 1.

        Parameters
        ----------
        n : int
            The number of the sample required. Note that `1 &lt;= n &lt;=
            number_of_samples`.

        Returns
        -------
        (, 7) numpy.ndarray
            A shallow copy of the lines from `line_data` included in
            sample number n.

        Raises
        ------
        IndexError
            If `sample_size == 0`, all data is returned as one single
            sample. Raised if `n` is not 1.
        IndexError
            If `n &gt; number_of_samples` or `n &lt;= 0`.

        &#39;&#39;&#39;
        if self._sample_size == 0:
            if n == 1:
                return self._line_data
            else:
                raise IndexError(&#34;\n\n[ERROR]: Trying to access a non-existent sample (samples are indexed from 1): asked for sample number {}, when there is only 1 sample (sample_size == 0)\n&#34;.format(n))
        elif (n &gt; self.number_of_samples) or n &lt;= 0:
            raise IndexError(&#34;\n\n[ERROR]: Trying to access a non-existent sample (samples are indexed from 1): asked for sample number {}, when there are {} samples\n&#34;.format(n, self.number_of_samples))

        start_index = (n - 1) * (self._sample_size - self._overlap)
        return self._line_data[start_index:(start_index + self._sample_size)]


    def to_csv(self, filepath, delimiter = &#39;  &#39;, newline = &#39;\n&#39;):
        &#39;&#39;&#39;Write `line_data` to a CSV file

        Write all LoRs stored in the class to a CSV file.

        Parameters
        ----------
            filepath : filename or file handle
                If filepath is a path (rather than file handle), it is relative
                to where python is called.
            delimiter : str, optional
                The delimiter between values. The default is two spaces &#39;  &#39;,
                such that numbers in the format &#39;123,456.78&#39; are well-understood.
            newline : str, optional
                The sequence of characters at the end of every line. The default
                is a new line &#39;\n&#39;

        &#39;&#39;&#39;
        np.savetxt(filepath, self._line_data, delimiter = delimiter, newline = newline)


    def plot_all_lines(self, ax = None, color=&#39;r&#39;, alpha=1.0 ):
        &#39;&#39;&#39;Plot all lines using matplotlib

        Given a **mpl_toolkits.mplot3d.Axes3D** axis `ax`, plots all lines on it.

        Parameters
        ----------
        ax : mpl_toolkits.mplot3D.Axes3D object
            The 3D matplotlib-based axis for plotting.

        color : matplotlib color option (default &#39;r&#39;)

        alpha : matplotlib opacity option (default 1.0)

        Returns
        -------

        fig, ax : matplotlib figure and axes objects

        Note
        ----
        Plotting all lines in the case of large LoR arrays is *very*
        computationally intensive. For large arrays (&gt; 10000), plotting
        individual samples using `plot_lines_sample_n` is recommended.

        &#39;&#39;&#39;

        if ax == None:
            fig = plt.figure()
            ax  = fig.add_subplot(111, projection=&#39;3d&#39;)
        else:
            fig = plt.gcf()

        p1 = self._line_data[:, 1:4]
        p2 = self._line_data[:, 4:7]

        for i in range(0, self._number_of_lines):
            ax.plot([ p1[i][0], p2[i][0] ],
                    [ p1[i][1], p2[i][1] ],
                    [ p1[i][2], p2[i][2] ],
                    c = color, alpha = alpha)

        return fig, ax


    def plot_all_lines_alt_axes(self, ax, color=&#39;r&#39;, alpha=1.0):
        &#39;&#39;&#39;Plot all lines using matplotlib on PEPT-style axes

        Given a **mpl_toolkits.mplot3d.Axes3D** axis `ax`, plots all lines on
        the PEPT-style convention: **x** is *parallel and horizontal* to the
        screens, **y** is *parallel and vertical* to the screens, **z** is
        *perpendicular* to the screens. The mapping relative to the
        Cartesian coordinates would then be: (x, y, z) -&gt; (z, x, y)

        Parameters
        ----------
        ax : mpl_toolkits.mplot3D.Axes3D object
            The 3D matplotlib-based axis for plotting.

        color : matplotlib color option (default &#39;r&#39;)

        alpha : matplotlib opacity option (default 1.0)

        Returns
        -------

        fig, ax : matplotlib figure and axes objects

        Note
        ----
        Plotting all lines in the case of large LoR arrays is *very*
        computationally intensive. For large arrays (&gt; 10000), plotting
        individual samples using `plot_lines_sample_n_alt_axes` is recommended.

        &#39;&#39;&#39;

        if ax == None:
            fig = plt.figure()
            ax  = fig.add_subplot(111, projection=&#39;3d&#39;)
        else:
            fig = plt.gcf()


        p1 = self._line_data[:, 1:4]
        p2 = self._line_data[:, 4:7]

        for i in range(0, self._number_of_lines):
            ax.plot([ p1[i][2], p2[i][2] ],
                    [ p1[i][0], p2[i][0] ],
                    [ p1[i][1], p2[i][1] ],
                    c = color, alpha=alpha)

        return fig, ax


    def plot_lines_sample_n(self, n, ax = None, color = &#39;r&#39;, alpha = 1.0):
        &#39;&#39;&#39;Plot lines from sample `n` using matplotlib

        Given a **mpl_toolkits.mplot3d.Axes3D** axis `ax`, plots all lines
        from sample number `n`.

        Parameters
        ----------
        ax : mpl_toolkits.mplot3D.Axes3D object
            The 3D matplotlib-based axis for plotting.

        sampleN : int
            The number of the sample to be plotted.

        color : matplotlib color option (default &#39;r&#39;)

        alpha : matplotlib opacity option (default 1.0)

        Returns
        -------

        fig, ax : matplotlib figure and axes objects

        &#39;&#39;&#39;

        if ax == None:
            fig = plt.figure()
            ax  = fig.add_subplot(111, projection=&#39;3d&#39;)
        else:
            fig = plt.gcf()

        sample = self.sample_n(n)
        for i in range(0, len(sample)):
            ax.plot([ sample[i][1], sample[i][4] ],
                    [ sample[i][2], sample[i][5] ],
                    [ sample[i][3], sample[i][6] ],
                    c = color, alpha = alpha)

        return fig, ax


    def plot_lines_sample_n_alt_axes(self, n, ax=None, color=&#39;r&#39;, alpha=1.0):
        &#39;&#39;&#39;Plot lines from sample `n` using matplotlib on PEPT-style axes

        Given a **mpl_toolkits.mplot3d.Axes3D** axis `ax`, plots all lines from
        sample number sampleN on the PEPT-style coordinates convention:
        **x** is *parallel and horizontal* to the screens, **y** is
        *parallel and vertical* to the screens, **z** is *perpendicular*
        to the screens. The mapping relative to the Cartesian coordinates
        would then be: (x, y, z) -&gt; (z, x, y)

        Parameters
        ----------
        ax : mpl_toolkits.mplot3D.Axes3D object
            The 3D matplotlib-based axis for plotting.
        n : int
            The number of the sample to be plotted.

        color : matplotlib color option (default &#39;r&#39;)

        alpha : matplotlib opacity option (default 1.0)

        Returns
        -------

        fig, ax : matplotlib figure and axes objects

        &#39;&#39;&#39;

        if ax == None:
            fig = plt.figure()
            ax  = fig.add_subplot(111, projection=&#39;3d&#39;)
        else:
            fig = plt.gcf()

        sample = self.sample_n(n)
        for i in range(0, len(sample)):
            ax.plot([ sample[i][3], sample[i][6] ],
                    [ sample[i][1], sample[i][4] ],
                    [ sample[i][2], sample[i][5] ],
                    c = color, alpha = alpha)

        return fig, ax


    def lines_trace(
        self,
        sample_indices = 0,
        width = 2,
        color = None,
        opacity = 0.6,
        colorbar = True,
        colorbar_col = 0,
        colorbar_title = None
    ):
        &#39;&#39;&#39;Get a Plotly trace for all the lines in selected samples.

        Creates a `plotly.graph_objects.Scatter3d` object for all the lines
        included in the samples selected by `sample_indices`. `sample_indices`
        can be a single sample index (e.g. 0) or an iterable of indices (e.g.
        [1,5,6]).
        Can then be passed to the `plotly.graph_objects.figure.add_trace`
        function or a `PlotlyGrapher` instance using the `add_trace` method.

        Parameters
        ----------
        sample_indices : int or iterable
            The index or indices of the samples of LoRs.
        width : float
            The width of the lines. The default is 2.
        color : str or list-like
            Can be a single color (e.g. &#34;black&#34;, &#34;rgb(122, 15, 241)&#34;) or a colorbar list.
            Is ignored if `colorbar` is set to True. For more information, check the Plotly
            documentation. The default is None.
        opacity : float
            The opacity of the lines, where 0 is transparent and 1 is fully
            opaque. The default is 0.6.
        colorbar : bool
            If set to True, will color-code the data in the sample column `colorbar_col`.
            Overrides `color` if set to True. The default is True, so that every line has
            a different color.
        colorbar_col : int
            The column in the data samples that will be used to color the points. Only has
            an effect if `colorbar` is set to True. The default is 0 (the first column - time).
        colorbar_title : str
            If set, the colorbar will have this title above. The default is None.

        Returns
        -------
        plotly.graph_objs.Scatter3d
            A Plotly trace of the LoRs.

        &#39;&#39;&#39;

        # Check if sample_indices is an iterable collection (list-like)
        # otherwise just &#34;iterate&#34; over the single number
        if not hasattr(sample_indices, &#34;__iter__&#34;):
            sample_indices = [sample_indices]

        marker = dict(
            width = width,
            color = color,
        )

        if colorbar:
            marker[&#39;color&#39;] = []
            marker.update(colorscale = &#34;Magma&#34;)

            if colorbar_title is not None:
                marker.update(colorbar = dict(title = colorbar_title))

        coords_x = []
        coords_y = []
        coords_z = []

        # For each selected sample include all the lines&#39; coordinates
        for n in sample_indices:
            sample = self[n]

            for line in sample:
                coords_x.extend([line[1], line[4], None])
                coords_y.extend([line[2], line[5], None])
                coords_z.extend([line[3], line[6], None])

                if colorbar:
                    marker[&#39;color&#39;].extend(3 * [line[colorbar_col]])

        trace = go.Scatter3d(
            x = coords_x,
            y = coords_y,
            z = coords_z,
            mode = &#39;lines&#39;,
            opacity = opacity,
            line = marker
        )

        return trace


    def __len__(self):
        # Defined so that len(class_instance) returns the number of samples.

        return self.number_of_samples


    def __str__(self):
        # Shown when calling print(class)
        docstr = &#34;&#34;

        docstr += &#34;number_of_lines =   {}\n\n&#34;.format(self.number_of_lines)
        docstr += &#34;sample_size =       {}\n&#34;.format(self._sample_size)
        docstr += &#34;overlap =           {}\n&#34;.format(self._overlap)
        docstr += &#34;number_of_samples = {}\n\n&#34;.format(self.number_of_samples)
        docstr += &#34;line_data = \n&#34;
        docstr += self._line_data.__str__()

        return docstr


    def __repr__(self):
        # Shown when writing the class on a REPR

        docstr = &#34;Class instance that inherits from `pept.LineData`.\n\n&#34; + self.__str__() + &#34;\n\n&#34;
        docstr += &#34;Particular cases:\n&#34;
        docstr += &#34; &gt; If sample_size == 0, all line_data is returned as one single sample.\n&#34;
        docstr += &#34; &gt; If overlap &gt;= sample_size, an error is raised.\n&#34;
        docstr += &#34; &gt; If overlap &lt; 0, lines are skipped between samples.\n&#34;

        return docstr


    def __getitem__(self, key):
        # Defined so that samples can be accessed as class_instance[0]

        if self.number_of_samples == 0:
            raise IndexError(&#34;Tried to access sample {} (indexed from 0), when there are {} samples&#34;.format(key, self.number_of_samples))

        if key &gt;= self.number_of_samples:
            raise IndexError(&#34;Tried to access sample {} (indexed from 0), when there are {} samples&#34;.format(key, self.number_of_samples))


        while key &lt; 0:
            key += self.number_of_samples

        return self.sample_n(key + 1)


    def __iter__(self):
        # Defined so the class can be iterated as `for sample in class_instance: ...`
        return self


    def __next__(self):
        # sample_size = 0 =&gt; return all data
        if self._sample_size == 0:
            self._sample_size = -1
            return self._line_data
        # Use -1 as a flag
        if self._sample_size == -1:
            self._sample_size = 0
            raise StopIteration

        # sample_size &gt; 0 =&gt; return slices
        if self._index != 0:
            self._index = self._index + self._sample_size - self.overlap
        else:
            self._index = self._index + self.sample_size


        if self._index &gt; self.number_of_lines:
            self._index = 0
            raise StopIteration

        return self._line_data[(self._index - self._sample_size):self._index]</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pept.scanners.parallel_screens.parallel_screens.ParallelScreens" href="scanners/parallel_screens/parallel_screens.html#pept.scanners.parallel_screens.parallel_screens.ParallelScreens">ParallelScreens</a></li>
<li><a title="pept.scanners.modular_camera.modular_camera.ModularCamera" href="scanners/modular_camera/modular_camera.html#pept.scanners.modular_camera.modular_camera.ModularCamera">ModularCamera</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pept.LineData.line_data"><code class="name">var <span class="ident">line_data</span></code></dt>
<dd>
<section class="desc"><p>Get the lines stored in the class.</p>
<h2 id="returns">Returns</h2>
<p>(, 7) numpy.ndarray
A memory view of the lines stored in <code>line_data</code>.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def line_data(self):
    &#39;&#39;&#39;Get the lines stored in the class.

    Returns
    -------
    (, 7) numpy.ndarray
        A memory view of the lines stored in `line_data`.

    &#39;&#39;&#39;

    return self._line_data</code></pre>
</details>
</dd>
<dt id="pept.LineData.number_of_lines"><code class="name">var <span class="ident">number_of_lines</span></code></dt>
<dd>
<section class="desc"><p>Get the number of lines stored in the class.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The number of lines stored in <code>line_data</code>.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def number_of_lines(self):
    &#39;&#39;&#39;Get the number of lines stored in the class.

    Returns
    -------
    int
        The number of lines stored in `line_data`.

    &#39;&#39;&#39;
    return self._number_of_lines</code></pre>
</details>
</dd>
<dt id="pept.LineData.number_of_samples"><code class="name">var <span class="ident">number_of_samples</span></code></dt>
<dd>
<section class="desc"><p>Get number of samples, considering overlap.</p>
<p>If <code>sample_size == 0</code>, all data is returned as a single sample,
and so <code>number_of_samples</code> will be 1. Otherwise, it checks the
number of samples every time it is called, taking <code>overlap</code> into
consideration.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The number of samples, taking <code>overlap</code> into consideration.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def number_of_samples(self):
    &#39;&#39;&#39;Get number of samples, considering overlap.

    If `sample_size == 0`, all data is returned as a single sample,
    and so `number_of_samples` will be 1. Otherwise, it checks the
    number of samples every time it is called, taking `overlap` into
    consideration.

    Returns
    -------
    int
        The number of samples, taking `overlap` into consideration.

    &#39;&#39;&#39;
    # If self.sample_size == 0, all data is returned as a single sample
    if self._sample_size == 0:
        return 1

    # If self.sample_size != 0, check there is at least one sample
    if self._number_of_lines &gt;= self._sample_size:
        return (self._number_of_lines - self._sample_size) // (self.sample_size - self.overlap) + 1
    else:
        return 0</code></pre>
</details>
</dd>
<dt id="pept.LineData.overlap"><code class="name">var <span class="ident">overlap</span></code></dt>
<dd>
<section class="desc"><p>Get the overlap between every two samples returned by the class.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The overlap (number of lines) between every two samples
returned by
the class.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def overlap(self):
    &#39;&#39;&#39;Get the overlap between every two samples returned by the class.

    Returns
    -------
    int
        The overlap (number of lines) between every two samples  returned by
        the class.

    &#39;&#39;&#39;

    return self._overlap</code></pre>
</details>
</dd>
<dt id="pept.LineData.sample_size"><code class="name">var <span class="ident">sample_size</span></code></dt>
<dd>
<section class="desc"><p>Get the number of lines in one sample returned by the class.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The sample size (number of lines) in one sample returned by
the class.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def sample_size(self):
    &#39;&#39;&#39;Get the number of lines in one sample returned by the class.

    Returns
    -------
    int
        The sample size (number of lines) in one sample returned by
        the class.

    &#39;&#39;&#39;

    return self._sample_size</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pept.LineData.lines_trace"><code class="name flex">
<span>def <span class="ident">lines_trace</span></span>(<span>self, sample_indices=0, width=2, color=None, opacity=0.6, colorbar=True, colorbar_col=0, colorbar_title=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Get a Plotly trace for all the lines in selected samples.</p>
<p>Creates a <code>plotly.graph_objects.Scatter3d</code> object for all the lines
included in the samples selected by <code>sample_indices</code>. <code>sample_indices</code>
can be a single sample index (e.g. 0) or an iterable of indices (e.g.
[1,5,6]).
Can then be passed to the <code>plotly.graph_objects.figure.add_trace</code>
function or a <code>PlotlyGrapher</code> instance using the <code>add_trace</code> method.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>sample_indices</code></strong> :&ensp;<code>int</code> or <code>iterable</code></dt>
<dd>The index or indices of the samples of LoRs.</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>float</code></dt>
<dd>The width of the lines. The default is 2.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code> or <code>list</code>-<code>like</code></dt>
<dd>Can be a single color (e.g. "black", "rgb(122, 15, 241)") or a colorbar list.
Is ignored if <code>colorbar</code> is set to True. For more information, check the Plotly
documentation. The default is None.</dd>
<dt><strong><code>opacity</code></strong> :&ensp;<code>float</code></dt>
<dd>The opacity of the lines, where 0 is transparent and 1 is fully
opaque. The default is 0.6.</dd>
<dt><strong><code>colorbar</code></strong> :&ensp;<code>bool</code></dt>
<dd>If set to True, will color-code the data in the sample column <code>colorbar_col</code>.
Overrides <code>color</code> if set to True. The default is True, so that every line has
a different color.</dd>
<dt><strong><code>colorbar_col</code></strong> :&ensp;<code>int</code></dt>
<dd>The column in the data samples that will be used to color the points. Only has
an effect if <code>colorbar</code> is set to True. The default is 0 (the first column - time).</dd>
<dt><strong><code>colorbar_title</code></strong> :&ensp;<code>str</code></dt>
<dd>If set, the colorbar will have this title above. The default is None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>plotly.graph_objs.Scatter3d</code></dt>
<dd>A Plotly trace of the LoRs.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def lines_trace(
    self,
    sample_indices = 0,
    width = 2,
    color = None,
    opacity = 0.6,
    colorbar = True,
    colorbar_col = 0,
    colorbar_title = None
):
    &#39;&#39;&#39;Get a Plotly trace for all the lines in selected samples.

    Creates a `plotly.graph_objects.Scatter3d` object for all the lines
    included in the samples selected by `sample_indices`. `sample_indices`
    can be a single sample index (e.g. 0) or an iterable of indices (e.g.
    [1,5,6]).
    Can then be passed to the `plotly.graph_objects.figure.add_trace`
    function or a `PlotlyGrapher` instance using the `add_trace` method.

    Parameters
    ----------
    sample_indices : int or iterable
        The index or indices of the samples of LoRs.
    width : float
        The width of the lines. The default is 2.
    color : str or list-like
        Can be a single color (e.g. &#34;black&#34;, &#34;rgb(122, 15, 241)&#34;) or a colorbar list.
        Is ignored if `colorbar` is set to True. For more information, check the Plotly
        documentation. The default is None.
    opacity : float
        The opacity of the lines, where 0 is transparent and 1 is fully
        opaque. The default is 0.6.
    colorbar : bool
        If set to True, will color-code the data in the sample column `colorbar_col`.
        Overrides `color` if set to True. The default is True, so that every line has
        a different color.
    colorbar_col : int
        The column in the data samples that will be used to color the points. Only has
        an effect if `colorbar` is set to True. The default is 0 (the first column - time).
    colorbar_title : str
        If set, the colorbar will have this title above. The default is None.

    Returns
    -------
    plotly.graph_objs.Scatter3d
        A Plotly trace of the LoRs.

    &#39;&#39;&#39;

    # Check if sample_indices is an iterable collection (list-like)
    # otherwise just &#34;iterate&#34; over the single number
    if not hasattr(sample_indices, &#34;__iter__&#34;):
        sample_indices = [sample_indices]

    marker = dict(
        width = width,
        color = color,
    )

    if colorbar:
        marker[&#39;color&#39;] = []
        marker.update(colorscale = &#34;Magma&#34;)

        if colorbar_title is not None:
            marker.update(colorbar = dict(title = colorbar_title))

    coords_x = []
    coords_y = []
    coords_z = []

    # For each selected sample include all the lines&#39; coordinates
    for n in sample_indices:
        sample = self[n]

        for line in sample:
            coords_x.extend([line[1], line[4], None])
            coords_y.extend([line[2], line[5], None])
            coords_z.extend([line[3], line[6], None])

            if colorbar:
                marker[&#39;color&#39;].extend(3 * [line[colorbar_col]])

    trace = go.Scatter3d(
        x = coords_x,
        y = coords_y,
        z = coords_z,
        mode = &#39;lines&#39;,
        opacity = opacity,
        line = marker
    )

    return trace</code></pre>
</details>
</dd>
<dt id="pept.LineData.plot_all_lines"><code class="name flex">
<span>def <span class="ident">plot_all_lines</span></span>(<span>self, ax=None, color='r', alpha=1.0)</span>
</code></dt>
<dd>
<section class="desc"><p>Plot all lines using matplotlib</p>
<p>Given a <strong>mpl_toolkits.mplot3d.Axes3D</strong> axis <code>ax</code>, plots all lines on it.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>mpl_toolkits.mplot3D.Axes3D</code> <code>object</code></dt>
<dd>The 3D matplotlib-based axis for plotting.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>matplotlib</code> <code>color</code> <code>option</code> (default <code>'r'</code>)</dt>
<dd>&nbsp;</dd>
<dt><strong><code>alpha</code></strong> :&ensp;<code>matplotlib</code> <code>opacity</code> <code>option</code> (default <code>1.0</code>)</dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong>, <strong><code>ax</code></strong> :&ensp;<code>matplotlib</code> <code>figure</code> <code>and</code> <code>axes</code> <code>objects</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="note">Note</h2>
<p>Plotting all lines in the case of large LoR arrays is <em>very</em>
computationally intensive. For large arrays (&gt; 10000), plotting
individual samples using <code>plot_lines_sample_n</code> is recommended.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def plot_all_lines(self, ax = None, color=&#39;r&#39;, alpha=1.0 ):
    &#39;&#39;&#39;Plot all lines using matplotlib

    Given a **mpl_toolkits.mplot3d.Axes3D** axis `ax`, plots all lines on it.

    Parameters
    ----------
    ax : mpl_toolkits.mplot3D.Axes3D object
        The 3D matplotlib-based axis for plotting.

    color : matplotlib color option (default &#39;r&#39;)

    alpha : matplotlib opacity option (default 1.0)

    Returns
    -------

    fig, ax : matplotlib figure and axes objects

    Note
    ----
    Plotting all lines in the case of large LoR arrays is *very*
    computationally intensive. For large arrays (&gt; 10000), plotting
    individual samples using `plot_lines_sample_n` is recommended.

    &#39;&#39;&#39;

    if ax == None:
        fig = plt.figure()
        ax  = fig.add_subplot(111, projection=&#39;3d&#39;)
    else:
        fig = plt.gcf()

    p1 = self._line_data[:, 1:4]
    p2 = self._line_data[:, 4:7]

    for i in range(0, self._number_of_lines):
        ax.plot([ p1[i][0], p2[i][0] ],
                [ p1[i][1], p2[i][1] ],
                [ p1[i][2], p2[i][2] ],
                c = color, alpha = alpha)

    return fig, ax</code></pre>
</details>
</dd>
<dt id="pept.LineData.plot_all_lines_alt_axes"><code class="name flex">
<span>def <span class="ident">plot_all_lines_alt_axes</span></span>(<span>self, ax, color='r', alpha=1.0)</span>
</code></dt>
<dd>
<section class="desc"><p>Plot all lines using matplotlib on PEPT-style axes</p>
<p>Given a <strong>mpl_toolkits.mplot3d.Axes3D</strong> axis <code>ax</code>, plots all lines on
the PEPT-style convention: <strong>x</strong> is <em>parallel and horizontal</em> to the
screens, <strong>y</strong> is <em>parallel and vertical</em> to the screens, <strong>z</strong> is
<em>perpendicular</em> to the screens. The mapping relative to the
Cartesian coordinates would then be: (x, y, z) -&gt; (z, x, y)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>mpl_toolkits.mplot3D.Axes3D</code> <code>object</code></dt>
<dd>The 3D matplotlib-based axis for plotting.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>matplotlib</code> <code>color</code> <code>option</code> (default <code>'r'</code>)</dt>
<dd>&nbsp;</dd>
<dt><strong><code>alpha</code></strong> :&ensp;<code>matplotlib</code> <code>opacity</code> <code>option</code> (default <code>1.0</code>)</dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong>, <strong><code>ax</code></strong> :&ensp;<code>matplotlib</code> <code>figure</code> <code>and</code> <code>axes</code> <code>objects</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="note">Note</h2>
<p>Plotting all lines in the case of large LoR arrays is <em>very</em>
computationally intensive. For large arrays (&gt; 10000), plotting
individual samples using <code>plot_lines_sample_n_alt_axes</code> is recommended.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def plot_all_lines_alt_axes(self, ax, color=&#39;r&#39;, alpha=1.0):
    &#39;&#39;&#39;Plot all lines using matplotlib on PEPT-style axes

    Given a **mpl_toolkits.mplot3d.Axes3D** axis `ax`, plots all lines on
    the PEPT-style convention: **x** is *parallel and horizontal* to the
    screens, **y** is *parallel and vertical* to the screens, **z** is
    *perpendicular* to the screens. The mapping relative to the
    Cartesian coordinates would then be: (x, y, z) -&gt; (z, x, y)

    Parameters
    ----------
    ax : mpl_toolkits.mplot3D.Axes3D object
        The 3D matplotlib-based axis for plotting.

    color : matplotlib color option (default &#39;r&#39;)

    alpha : matplotlib opacity option (default 1.0)

    Returns
    -------

    fig, ax : matplotlib figure and axes objects

    Note
    ----
    Plotting all lines in the case of large LoR arrays is *very*
    computationally intensive. For large arrays (&gt; 10000), plotting
    individual samples using `plot_lines_sample_n_alt_axes` is recommended.

    &#39;&#39;&#39;

    if ax == None:
        fig = plt.figure()
        ax  = fig.add_subplot(111, projection=&#39;3d&#39;)
    else:
        fig = plt.gcf()


    p1 = self._line_data[:, 1:4]
    p2 = self._line_data[:, 4:7]

    for i in range(0, self._number_of_lines):
        ax.plot([ p1[i][2], p2[i][2] ],
                [ p1[i][0], p2[i][0] ],
                [ p1[i][1], p2[i][1] ],
                c = color, alpha=alpha)

    return fig, ax</code></pre>
</details>
</dd>
<dt id="pept.LineData.plot_lines_sample_n"><code class="name flex">
<span>def <span class="ident">plot_lines_sample_n</span></span>(<span>self, n, ax=None, color='r', alpha=1.0)</span>
</code></dt>
<dd>
<section class="desc"><p>Plot lines from sample <code>n</code> using matplotlib</p>
<p>Given a <strong>mpl_toolkits.mplot3d.Axes3D</strong> axis <code>ax</code>, plots all lines
from sample number <code>n</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>mpl_toolkits.mplot3D.Axes3D</code> <code>object</code></dt>
<dd>The 3D matplotlib-based axis for plotting.</dd>
<dt><strong><code>sampleN</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of the sample to be plotted.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>matplotlib</code> <code>color</code> <code>option</code> (default <code>'r'</code>)</dt>
<dd>&nbsp;</dd>
<dt><strong><code>alpha</code></strong> :&ensp;<code>matplotlib</code> <code>opacity</code> <code>option</code> (default <code>1.0</code>)</dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong>, <strong><code>ax</code></strong> :&ensp;<code>matplotlib</code> <code>figure</code> <code>and</code> <code>axes</code> <code>objects</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def plot_lines_sample_n(self, n, ax = None, color = &#39;r&#39;, alpha = 1.0):
    &#39;&#39;&#39;Plot lines from sample `n` using matplotlib

    Given a **mpl_toolkits.mplot3d.Axes3D** axis `ax`, plots all lines
    from sample number `n`.

    Parameters
    ----------
    ax : mpl_toolkits.mplot3D.Axes3D object
        The 3D matplotlib-based axis for plotting.

    sampleN : int
        The number of the sample to be plotted.

    color : matplotlib color option (default &#39;r&#39;)

    alpha : matplotlib opacity option (default 1.0)

    Returns
    -------

    fig, ax : matplotlib figure and axes objects

    &#39;&#39;&#39;

    if ax == None:
        fig = plt.figure()
        ax  = fig.add_subplot(111, projection=&#39;3d&#39;)
    else:
        fig = plt.gcf()

    sample = self.sample_n(n)
    for i in range(0, len(sample)):
        ax.plot([ sample[i][1], sample[i][4] ],
                [ sample[i][2], sample[i][5] ],
                [ sample[i][3], sample[i][6] ],
                c = color, alpha = alpha)

    return fig, ax</code></pre>
</details>
</dd>
<dt id="pept.LineData.plot_lines_sample_n_alt_axes"><code class="name flex">
<span>def <span class="ident">plot_lines_sample_n_alt_axes</span></span>(<span>self, n, ax=None, color='r', alpha=1.0)</span>
</code></dt>
<dd>
<section class="desc"><p>Plot lines from sample <code>n</code> using matplotlib on PEPT-style axes</p>
<p>Given a <strong>mpl_toolkits.mplot3d.Axes3D</strong> axis <code>ax</code>, plots all lines from
sample number sampleN on the PEPT-style coordinates convention:
<strong>x</strong> is <em>parallel and horizontal</em> to the screens, <strong>y</strong> is
<em>parallel and vertical</em> to the screens, <strong>z</strong> is <em>perpendicular</em>
to the screens. The mapping relative to the Cartesian coordinates
would then be: (x, y, z) -&gt; (z, x, y)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>mpl_toolkits.mplot3D.Axes3D</code> <code>object</code></dt>
<dd>The 3D matplotlib-based axis for plotting.</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of the sample to be plotted.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>matplotlib</code> <code>color</code> <code>option</code> (default <code>'r'</code>)</dt>
<dd>&nbsp;</dd>
<dt><strong><code>alpha</code></strong> :&ensp;<code>matplotlib</code> <code>opacity</code> <code>option</code> (default <code>1.0</code>)</dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong>, <strong><code>ax</code></strong> :&ensp;<code>matplotlib</code> <code>figure</code> <code>and</code> <code>axes</code> <code>objects</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def plot_lines_sample_n_alt_axes(self, n, ax=None, color=&#39;r&#39;, alpha=1.0):
    &#39;&#39;&#39;Plot lines from sample `n` using matplotlib on PEPT-style axes

    Given a **mpl_toolkits.mplot3d.Axes3D** axis `ax`, plots all lines from
    sample number sampleN on the PEPT-style coordinates convention:
    **x** is *parallel and horizontal* to the screens, **y** is
    *parallel and vertical* to the screens, **z** is *perpendicular*
    to the screens. The mapping relative to the Cartesian coordinates
    would then be: (x, y, z) -&gt; (z, x, y)

    Parameters
    ----------
    ax : mpl_toolkits.mplot3D.Axes3D object
        The 3D matplotlib-based axis for plotting.
    n : int
        The number of the sample to be plotted.

    color : matplotlib color option (default &#39;r&#39;)

    alpha : matplotlib opacity option (default 1.0)

    Returns
    -------

    fig, ax : matplotlib figure and axes objects

    &#39;&#39;&#39;

    if ax == None:
        fig = plt.figure()
        ax  = fig.add_subplot(111, projection=&#39;3d&#39;)
    else:
        fig = plt.gcf()

    sample = self.sample_n(n)
    for i in range(0, len(sample)):
        ax.plot([ sample[i][3], sample[i][6] ],
                [ sample[i][1], sample[i][4] ],
                [ sample[i][2], sample[i][5] ],
                c = color, alpha = alpha)

    return fig, ax</code></pre>
</details>
</dd>
<dt id="pept.LineData.sample_n"><code class="name flex">
<span>def <span class="ident">sample_n</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<section class="desc"><p>Get sample number n (indexed from 1, i.e. <code>n &gt; 0</code>)</p>
<p>Returns the lines from <code>line_data</code> included in sample number
<code>n</code>. Samples are numbered starting from 1.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of the sample required. Note that <code>1 &lt;= n &lt;=
number_of_samples</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>(, 7) numpy.ndarray
A shallow copy of the lines from <code>line_data</code> included in
sample number n.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>IndexError</code></dt>
<dd>If <code>sample_size == 0</code>, all data is returned as one single
sample. Raised if <code>n</code> is not 1.</dd>
<dt><code>IndexError</code></dt>
<dd>If <code>n &gt; number_of_samples</code> or <code>n &lt;= 0</code>.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def sample_n(self, n):
    &#39;&#39;&#39;Get sample number n (indexed from 1, i.e. `n &gt; 0`)

    Returns the lines from `line_data` included in sample number
    `n`. Samples are numbered starting from 1.

    Parameters
    ----------
    n : int
        The number of the sample required. Note that `1 &lt;= n &lt;=
        number_of_samples`.

    Returns
    -------
    (, 7) numpy.ndarray
        A shallow copy of the lines from `line_data` included in
        sample number n.

    Raises
    ------
    IndexError
        If `sample_size == 0`, all data is returned as one single
        sample. Raised if `n` is not 1.
    IndexError
        If `n &gt; number_of_samples` or `n &lt;= 0`.

    &#39;&#39;&#39;
    if self._sample_size == 0:
        if n == 1:
            return self._line_data
        else:
            raise IndexError(&#34;\n\n[ERROR]: Trying to access a non-existent sample (samples are indexed from 1): asked for sample number {}, when there is only 1 sample (sample_size == 0)\n&#34;.format(n))
    elif (n &gt; self.number_of_samples) or n &lt;= 0:
        raise IndexError(&#34;\n\n[ERROR]: Trying to access a non-existent sample (samples are indexed from 1): asked for sample number {}, when there are {} samples\n&#34;.format(n, self.number_of_samples))

    start_index = (n - 1) * (self._sample_size - self._overlap)
    return self._line_data[start_index:(start_index + self._sample_size)]</code></pre>
</details>
</dd>
<dt id="pept.LineData.to_csv"><code class="name flex">
<span>def <span class="ident">to_csv</span></span>(<span>self, filepath, delimiter='
', newline='\n')</span>
</code></dt>
<dd>
<section class="desc"><p>Write <code>line_data</code> to a CSV file</p>
<pre><code>    Write all LoRs stored in the class to a CSV file.

    Parameters
    ----------
        filepath : filename or file handle
            If filepath is a path (rather than file handle), it is relative
            to where python is called.
        delimiter : str, optional
            The delimiter between values. The default is two spaces '  ',
            such that numbers in the format '123,456.78' are well-understood.
        newline : str, optional
            The sequence of characters at the end of every line. The default
            is a new line '
</code></pre>
<p>'</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def to_csv(self, filepath, delimiter = &#39;  &#39;, newline = &#39;\n&#39;):
    &#39;&#39;&#39;Write `line_data` to a CSV file

    Write all LoRs stored in the class to a CSV file.

    Parameters
    ----------
        filepath : filename or file handle
            If filepath is a path (rather than file handle), it is relative
            to where python is called.
        delimiter : str, optional
            The delimiter between values. The default is two spaces &#39;  &#39;,
            such that numbers in the format &#39;123,456.78&#39; are well-understood.
        newline : str, optional
            The sequence of characters at the end of every line. The default
            is a new line &#39;\n&#39;

    &#39;&#39;&#39;
    np.savetxt(filepath, self._line_data, delimiter = delimiter, newline = newline)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pept.PointData"><code class="flex name class">
<span>class <span class="ident">PointData</span></span>
<span>(</span><span>point_data, sample_size=0, overlap=0, verbose=False)</span>
</code></dt>
<dd>
<section class="desc"><p>A class for generic PEPT data iteration, manipulation and visualisation.</p>
<p>This class is used to encapsulate points. Unlike <a title="pept.LineData" href="#pept.LineData"><code>LineData</code></a>, it does not have
any restriction on the maximum number of columns it can store. It can yield
samples of the <code>point_data</code> of an adaptive <code>sample_size</code> and <code>overlap</code>,
without requiring additional storage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>point_data</code></strong> :&ensp;(<code>N</code>, <code>M</code>) <code>numpy.ndarray</code></dt>
<dd>An (N, M &gt;= 4) numpy array that stores points (or any generic 2D set of
data). It expects that the first column is time, followed by cartesian
(3D) coordinates of points <strong>in mm</strong>, followed by any extra information
the user needs. A row is then [time, x, y, z, etc].</dd>
<dt><strong><code>sample_size</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>An <code>int`` that defines the number of points that should be
returned when iterating over</code>point_data<code>. A</code>sample_size` of 0
yields all the data as one single sample. (Default is 200)</dd>
<dt><strong><code>overlap</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>An <code>int</code> that defines the overlap between two consecutive
samples that are returned when iterating over <code>point_data</code>.
An overlap of 0 means consecutive samples, while an overlap
of (<code>sample_size</code> - 1) means incrementing the samples by one.
A negative overlap means skipping values between samples. An
error is raised if <code>overlap</code> is larger than or equal to
<code>sample_size</code>. (Default is 0)</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>An option that enables printing the time taken for the
initialisation of an instance of the class. Useful when
reading large files (10gb files for PEPT data is not unheard
of). (Default is True)</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>point_data</code></strong> :&ensp;(<code>N</code>, <code>M</code>) <code>numpy.ndarray</code></dt>
<dd>An (N, M &gt;= 4) numpy array that stores the points as time, followed by
cartesian (3D) coordinates of the point <strong>in mm</strong>, followed by any extra
information. Each row is then <code>[time, x, y, z, etc]</code>.</dd>
<dt><strong><code>sample_size</code></strong> :&ensp;<code>int</code></dt>
<dd>An <code>int</code> that defines the number of lines that should be
returned when iterating over <code>point_data</code>. (Default is 200)</dd>
<dt><strong><code>overlap</code></strong> :&ensp;<code>int</code></dt>
<dd>An <code>int</code> that defines the overlap between two consecutive
samples that are returned when iterating over <code>point_data</code>.
An overlap of 0 means consecutive samples, while an overlap
of (<code>sample_size</code> - 1) means incrementing the samples by one.
A negative overlap means skipping values between samples. It
is required to be smaller than <code>sample_size</code>. (Default is 0)</dd>
<dt><strong><code>number_of_points</code></strong> :&ensp;<code>int</code></dt>
<dd>An <code>int</code> that corresponds to len(<code>point_data</code>), or the number of
points stored by <code>point_data</code>.</dd>
<dt><strong><code>number_of_samples</code></strong> :&ensp;<code>int</code></dt>
<dd>An <code>int</code> that corresponds to the number of samples that can be
accessed from the class, taking the <code>overlap</code> into consideration.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If <code>overlap</code> &gt;= <code>sample_size</code>. Overlap is required to be smaller
than <code>sample_size</code>, unless <code>sample_size</code> is 0. Note that it can
also be negative.</dd>
<dt><code>ValueError</code></dt>
<dd>If <code>line_data</code> does not have (N, M) shape, where M &gt;= 4.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The class saves <code>point_data</code> as a <strong>contiguous</strong> numpy array for
efficient access in C extensions.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class PointData:
    &#39;&#39;&#39;A class for generic PEPT data iteration, manipulation and visualisation.

    This class is used to encapsulate points. Unlike `LineData`, it does not have
    any restriction on the maximum number of columns it can store. It can yield
    samples of the `point_data` of an adaptive `sample_size` and `overlap`,
    without requiring additional storage.

    Parameters
    ----------
    point_data : (N, M) numpy.ndarray
        An (N, M &gt;= 4) numpy array that stores points (or any generic 2D set of
        data). It expects that the first column is time, followed by cartesian
        (3D) coordinates of points **in mm**, followed by any extra information
        the user needs. A row is then [time, x, y, z, etc].
    sample_size : int, optional
        An `int`` that defines the number of points that should be
        returned when iterating over `point_data`. A `sample_size` of 0
        yields all the data as one single sample. (Default is 200)
    overlap : int, optional
        An `int` that defines the overlap between two consecutive
        samples that are returned when iterating over `point_data`.
        An overlap of 0 means consecutive samples, while an overlap
        of (`sample_size` - 1) means incrementing the samples by one.
        A negative overlap means skipping values between samples. An
        error is raised if `overlap` is larger than or equal to
        `sample_size`. (Default is 0)
    verbose : bool, optional
        An option that enables printing the time taken for the
        initialisation of an instance of the class. Useful when
        reading large files (10gb files for PEPT data is not unheard
        of). (Default is True)

    Attributes
    ----------
    point_data : (N, M) numpy.ndarray
        An (N, M &gt;= 4) numpy array that stores the points as time, followed by
        cartesian (3D) coordinates of the point **in mm**, followed by any extra
        information. Each row is then `[time, x, y, z, etc]`.
    sample_size : int
        An `int` that defines the number of lines that should be
        returned when iterating over `point_data`. (Default is 200)
    overlap : int
        An `int` that defines the overlap between two consecutive
        samples that are returned when iterating over `point_data`.
        An overlap of 0 means consecutive samples, while an overlap
        of (`sample_size` - 1) means incrementing the samples by one.
        A negative overlap means skipping values between samples. It
        is required to be smaller than `sample_size`. (Default is 0)
    number_of_points : int
        An `int` that corresponds to len(`point_data`), or the number of
        points stored by `point_data`.
    number_of_samples : int
        An `int` that corresponds to the number of samples that can be
        accessed from the class, taking the `overlap` into consideration.

    Raises
    ------
    ValueError
        If `overlap` &gt;= `sample_size`. Overlap is required to be smaller
        than `sample_size`, unless `sample_size` is 0. Note that it can
        also be negative.
    ValueError
        If `line_data` does not have (N, M) shape, where M &gt;= 4.

    Notes
    -----
    The class saves `point_data` as a **contiguous** numpy array for
    efficient access in C extensions.

    &#39;&#39;&#39;


    def __init__(
        self,
        point_data,
        sample_size = 0,
        overlap = 0,
        verbose = False
    ):

        if verbose:
            start = time.time()

        if sample_size &lt; 0:
            raise ValueError(&#39;\n[ERROR]: sample_size = {} must be positive (&gt;= 0)&#39;.format(sample_size))
        if sample_size != 0 and overlap &gt;= sample_size:
            raise ValueError(&#39;\n[ERROR]: overlap = {} must be smaller than sample_size = {}\n&#39;.format(overlap, sample_size))

        self._index = 0
        self._sample_size = sample_size
        self._overlap = overlap

        self._point_data = np.asarray(point_data, order = &#39;C&#39;, dtype = float)

        if self._point_data.ndim != 2 or self._point_data.shape[1] &lt; 4:
            raise ValueError(&#39;\n[ERROR]: point_data should have two dimensions (M, N), where N &gt;= 4. Received {}\n&#39;.format(self._point_data.shape))

        self._number_of_points = len(self._point_data)

        if verbose:
            end = time.time()
            print(&#34;Initialising the PEPT data took {} seconds\n&#34;.format(end - start))


    @property
    def point_data(self):
        &#39;&#39;&#39;Get the points stored in the class.

        Returns
        -------
        (M, N) numpy.ndarray
            A memory view of the points stored in `point_data`.

        &#39;&#39;&#39;

        return self._point_data


    @property
    def sample_size(self):
        &#39;&#39;&#39;Get the number of points in one sample returned by the class.

        Returns
        -------
        int
            The sample size (number of lines) in one sample returned by
            the class.

        &#39;&#39;&#39;

        return self._sample_size


    @sample_size.setter
    def sample_size(self, new_sample_size):
        &#39;&#39;&#39;Change `sample_size` without instantiating a new object

        It also resets the inner index of the class.

        Parameters
        ----------
        new_sample_size : int
            The new sample size. It has to be larger than `overlap`,
            unless it is 0 (in which case all `point_data` will be returned
            as one sample).

        Raises
        ------
        ValueError
            If `overlap` &gt;= `new_sample_size`. Overlap has to be
            smaller than `sample_size`, unless `sample_size` is 0.
            Note that it can also be negative.

        &#39;&#39;&#39;

        if new_sample_size &lt; 0:
            raise ValueError(&#39;\n[ERROR]: sample_size = {} must be positive (&gt;= 0)&#39;.format(new_sample_size))
        if new_sample_size != 0 and self._overlap &gt;= new_sample_size:
            raise ValueError(&#39;\n[ERROR]: overlap = {} must be smaller than new_sample_size = {}\n&#39;.format(self._overlap, new_sample_size))

        self._index = 0
        self._sample_size = new_sample_size


    @property
    def overlap(self):
        &#39;&#39;&#39;Get the overlap between every two samples returned by the class.

        Returns
        -------
        int
            The overlap (number of points) between every two samples  returned by
            the class.

        &#39;&#39;&#39;

        return self._overlap


    @overlap.setter
    def overlap(self, new_overlap):
        &#39;&#39;&#39;Change `overlap` without instantiating a new object

        It also resets the inner index of the class.

        Parameters
        ----------
        new_overlap : int
            The new overlap. It has to be smaller than `sample_size`, unless
            `sample_size` is 0 (in which case all `point_data` will be returned
            as one sample and so overlap does not play any role).

        Raises
        ------
        ValueError
            If `new_overlap` &gt;= `sample_size`. `new_overlap` has to be
            smaller than `sample_size`, unless `sample_size` is 0.
            Note that it can also be negative.

        &#39;&#39;&#39;

        if self._sample_size != 0 and new_overlap &gt;= self._sample_size:
            raise ValueError(&#39;\n[ERROR]: new_overlap = {} must be smaller than sample_size = {}\n&#39;.format(new_overlap, self._sample_size))

        self._index = 0
        self._overlap = new_overlap


    @property
    def number_of_samples(self):
        &#39;&#39;&#39;Get number of samples, considering overlap.

        If `sample_size == 0`, all data is returned as a single sample,
        and so `number_of_samples` will be 1. Otherwise, it checks the
        number of samples every time it is called, taking `overlap` into
        consideration.

        Returns
        -------
        int
            The number of samples, taking `overlap` into consideration.

        &#39;&#39;&#39;
        # If self.sample_size == 0, all data is returned as a single sample
        if self._sample_size == 0:
            return 1

        # If self.sample_size != 0, check there is at least one sample
        if self._number_of_points &gt;= self._sample_size:
            return (self._number_of_points - self._sample_size) // (self.sample_size - self.overlap) + 1
        else:
            return 0


    @property
    def number_of_points(self):
        &#39;&#39;&#39;Get the number of points stored in the class.

        Returns
        -------
        int
            The number of points stored in `point_data`.

        &#39;&#39;&#39;
        return self._number_of_points


    def sample_n(self, n):
        &#39;&#39;&#39;Get sample number n (indexed from 1, i.e. `n &gt; 0`)

        Returns the lines from `point_data` included in sample number
        `n`. Samples are numbered starting from 1.

        Parameters
        ----------
        n : int
            The number of the sample required. Note that `1 &lt;= n &lt;=
            number_of_samples`.

        Returns
        -------
        (M, N) numpy.ndarray
            A shallow copy of the points from `point_data` included in
            sample number n.

        Raises
        ------
        IndexError
            If `sample_size == 0`, all data is returned as one single
            sample. Raised if `n` is not 1.
        IndexError
            If `n &gt; number_of_samples` or `n &lt;= 0`.

        &#39;&#39;&#39;
        if self._sample_size == 0:
            if n == 1:
                return self._point_data
            else:
                raise IndexError(&#34;\n\n[ERROR]: Trying to access a non-existent sample (samples indexed from 1): asked for sample number {}, when there is only 1 sample (sample_size == 0)\n&#34;.format(n))
        elif (n &gt; self.number_of_samples) or n &lt;= 0:
            raise IndexError(&#34;\n\n[ERROR]: Trying to access a non-existent sample (samples are indexed from 1): asked for sample number {}, when there are {} samples\n&#34;.format(n, self.number_of_samples))

        start_index = (n - 1) * (self._sample_size - self._overlap)
        return self._point_data[start_index:(start_index + self._sample_size)]


    def to_csv(self, filepath, delimiter = &#39;  &#39;, newline = &#39;\n&#39;):
        &#39;&#39;&#39;Write `point_data` to a CSV file

        Write all points (and any extra data) stored in the class to a CSV file.

        Parameters
        ----------
            filepath : filename or file handle
                If filepath is a path (rather than file handle), it is relative
                to where python is called.
            delimiter : str, optional
                The delimiter between values. The default is two spaces &#39;  &#39;,
                such that numbers in the format &#39;123,456.78&#39; are well-understood.
            newline : str, optional
                The sequence of characters at the end of every line. The default
                is a new line &#39;\n&#39;

        &#39;&#39;&#39;
        np.savetxt(filepath, self._point_data, delimiter = delimiter, newline = newline)


    def plot_all_points(self, ax = None):
        &#39;&#39;&#39;Plot all points using matplotlib

        Given a **mpl_toolkits.mplot3d.Axes3D** axis, plots all points on it.

        Parameters
        ----------
        ax : mpl_toolkits.mplot3D.Axes3D object
            The 3D matplotlib-based axis for plotting.

        Returns
        -------
        fig, ax : matplotlib figure and axes objects

        Note
        ----
        Plotting all points in the case of large LoR arrays is *very*
        computationally intensive. For large arrays (&gt; 10000), plotting
        individual samples using `plot_points_sample_n` is recommended.

        &#39;&#39;&#39;

        if ax == None:
            fig = plt.figure()
            ax  = fig.add_subplot(111, projection=&#39;3d&#39;)
        else:
            fig = plt.gcf()

        # Scatter x, y, z, [color]

        x = self._point_data[:, 1],
        y = self._point_data[:, 2],
        z = self._point_data[:, 3],

        color = self._point_data[:, -1],

        cmap = plt.cm.magma
        color_array = cmap(colour_data)

        ax.scatter(x,y,z,c=color_array[0])

        return fig, ax


    def plot_all_points_alt_axes(self, ax = None ):
        &#39;&#39;&#39;Plot all points using matplotlib on PEPT-style axes

        Given a **mpl_toolkits.mplot3d.Axes3D** axis, plots all points on
        the PEPT-style convention: **x** is *parallel and horizontal* to the
        screens, **y** is *parallel and vertical* to the screens, **z** is
        *perpendicular* to the screens. The mapping relative to the
        Cartesian coordinates would then be: (x, y, z) -&gt; (z, x, y)

        Parameters
        ----------
        ax : mpl_toolkits.mplot3D.Axes3D object
            The 3D matplotlib-based axis for plotting.

        Returns
        -------
        fig, ax : matplotlib figure and axes objects

        Note
        ----
        Plotting all points in the case of large LoR arrays is *very*
        computationally intensive. For large arrays (&gt; 10000), plotting
        individual samples using `plot_lines_sample_n_alt_axes` is recommended.

        &#39;&#39;&#39;

        if ax == None:
            fig = plt.figure()
            ax  = fig.add_subplot(111, projection=&#39;3d&#39;)
        else:
            fig = plt.gcf()

        # Scatter x, y, z, [color]

        x = self._point_data[:, 1]
        y = self._point_data[:, 2]
        z = self._point_data[:, 3]

        color = self._point_data[:, -1]

        cmap = plt.cm.magma
        color_array = cmap(color)

        ax.scatter(z,x,y,c=color_array[0])

        return fig, ax


    def plot_points_sample_n(self, n, ax=None):
        &#39;&#39;&#39;Plot points from sample `n` using matplotlib

        Given a **mpl_toolkits.mplot3d.Axes3D** axis, plots all points
        from sample number `n`.

        Parameters
        ----------
        ax : mpl_toolkits.mplot3D.Axes3D object
            The 3D matplotlib-based axis for plotting.
        n : int
            The number of the sample to be plotted.

        Returns
        -------

        fig, ax : matplotlib figure and axes objects

        &#39;&#39;&#39;

        if ax == None:
            fig = plt.figure()
            ax  = fig.add_subplot(111, projection=&#39;3d&#39;)
        else:
            fig = plt.gcf()

        # Scatter x, y, z, [color]

        sample = self.sample_n(n)

        x = sample[:, 1]
        y = sample[:, 2]
        z = sample[:, 3]

        color = sample[:, -1]

        cmap = plt.cm.magma
        color_array = cmap(color)

        ax.scatter(z,x,y,c=color_array[0])

        return fig, ax


    def plot_points_sample_n_alt_axes(self, n, ax=None):
        &#39;&#39;&#39;Plot points from sample `n` using matplotlib on PEPT-style axes

        Given a **mpl_toolkits.mplot3d.Axes3D** axis, plots all points from
        sample number sampleN on the PEPT-style coordinates convention:
        **x** is *parallel and horizontal* to the screens, **y** is
        *parallel and vertical* to the screens, **z** is *perpendicular*
        to the screens. The mapping relative to the Cartesian coordinates
        would then be: (x, y, z) -&gt; (z, x, y)

        Parameters
        ----------
        ax : mpl_toolkits.mplot3D.Axes3D object
            The 3D matplotlib-based axis for plotting.
        n : int
            The number of the sample to be plotted.

        Returns
        -------

        fig, ax : matplotlib figure and axes objects
        &#39;&#39;&#39;

        if ax == None:
            fig = plt.figure()
            ax  = fig.add_subplot(111, projection=&#39;3d&#39;)
        else:
            fig = plt.gcf()

        # Scatter x, y, z, [color]

        sample = self.sample_n(n)

        x = sample[:, 1]
        y = sample[:, 2]
        z = sample[:, 3]

        color = sample[:, -1]

        cmap = plt.cm.magma
        color_array = cmap(color)

        ax.scatter(z,x,y,c=color_array[0])

        return fig, ax


    def all_points_trace(self, size = 2, color = None):
        &#39;&#39;&#39;Get a Plotly trace of all points.

        Creates a `plotly.graph_objects.Scatter3d` object. Can
        then be passed to the `plotly.graph_objects.figure.add_trace`
        function or a `PlotlyGrapher` instance using the `add_trace` method.

        Returns
        -------
        plotly.graph_objects.Scatter3d
            A `plotly.graph_objects.Scatter3d` trace of all points.

        Note
        ----
        Plotting all points in the case of large LoR arrays is *very*
        computationally intensive. For large arrays (&gt; 10000), plotting
        individual samples using `points_sample_n_traces` is recommended.

        &#39;&#39;&#39;

        trace = go.Scatter3d(
            x = self._point_data[:, 1],
            y = self._point_data[:, 2],
            z = self._point_data[:, 3],
            mode = &#39;markers&#39;,
            marker = dict(
                size = size,
                color = color,
                opacity = 0.8
            )
        )

        return trace


    def all_points_trace_colorbar(self, size = 2, colorbar_title = None):
        &#39;&#39;&#39;Get a Plotly trace of all points, colour-coding the last column of `point_data`.

        Creates a `plotly.graph_objects.Scatter3d` object. Can
        then be passed to the `plotly.graph_objects.figure.add_trace`
        function or a `PlotlyGrapher` instance using the `add_trace` method.

        Returns
        -------
        plotly.graph_objects.Scatter3d
            A `plotly.graph_objects.Scatter3d` trace of all points.

        Note
        ----
        Plotting all points in the case of large LoR arrays is *very*
        computationally intensive. For large arrays (&gt; 10000), plotting
        individual samples using `points_sample_n_traces` is recommended.

        &#39;&#39;&#39;

        if colorbar_title != None:
            colorbar = dict(title = colorbar_title)
        else:
            colorbar = dict()

        trace = go.Scatter3d(
            x = self._point_data[:, 1],
            y = self._point_data[:, 2],
            z = self._point_data[:, 3],
            mode = &#39;markers&#39;,
            marker = dict(
                size = size,
                color = self._point_data[:, -1],
                colorscale = &#39;Magma&#39;,
                colorbar = colorbar,
                opacity = 0.8
            )
        )

        return trace


    def points_sample_n_trace(self, n, size = 2, color = None):
        &#39;&#39;&#39;Get a Plotly trace for all points in sample `n`.

        Returns a `plotly.graph_objects.Scatter3d` trace containing all points
        included in sample number `n`.
        Can then be passed to the `plotly.graph_objects.figure.add_trace`
        function or a `PlotlyGrapher` instance using the `add_trace` method.

        Parameters
        ----------
        n : int
            The number of the sample to be plotted.

        Returns
        -------
        plotly.graph_object.Scatter3d
            A `plotly.graph_objects.Scatter3d` trace of all points in sample `n`.

        &#39;&#39;&#39;

        sample = self.sample_n(n)
        trace = go.Scatter3d(
            x = sample[:, 1],
            y = sample[:, 2],
            z = sample[:, 3],
            mode = &#39;markers&#39;,
            marker = dict(
                size = size,
                color = color,
                opacity = 0.8
            )
        )

        return trace


    def points_sample_n_trace_colorbar(self, n, size = 2, colorbar_title = None):
        &#39;&#39;&#39;Get a Plotly trace for all points in sample `n`, colour-coding the last column.

        Returns a `plotly.graph_objects.Scatter3d` trace containing all points
        included in sample number `n`.
        Can then be passed to the `plotly.graph_objects.figure.add_trace`
        function or a `PlotlyGrapher` instance using the `add_trace` method.

        Parameters
        ----------
        n : int
            The number of the sample to be plotted.

        Returns
        -------
        plotly.graph_object.Scatter3d
            A `plotly.graph_objects.Scatter3d` trace of all points in sample `n`.

        &#39;&#39;&#39;

        if colorbar_title != None:
            colorbar = dict(title = colorbar_title)
        else:
            colorbar = dict()

        sample = self.sample_n(n)
        trace = go.Scatter3d(
            x = sample[:, 1],
            y = sample[:, 2],
            z = sample[:, 3],
            mode = &#39;markers&#39;,
            marker = dict(
                size = size,
                color = sample[:, -1],
                colorscale = &#39;Magma&#39;,
                colorbar = colorbar,
                opacity = 0.8
            )
        )

        return trace


    def points_trace(
        self,
        sample_indices = 0,
        size = 2,
        color = None,
        opacity = 0.8,
        colorbar = False,
        colorbar_col = -1,
        colorbar_title = None
    ):
        &#39;&#39;&#39;Get a Plotly trace for all points in selected samples, with possible color-coding.

        Returns a `plotly.graph_objects.Scatter3d` trace containing all points
        included in in the samples selected by `sample_indices`. `sample_indices`
        can be a single sample index (e.g. 0) or an iterable of indices (e.g.
        [1,5,6]).
        Can then be passed to the `plotly.graph_objects.figure.add_trace`
        function or a `PlotlyGrapher` instance using the `add_trace` method.

        Parameters
        ----------
        sample_indices : int or iterable
            The index or indices of the samples of LoRs. The default is 0 (the first sample).
        size : float
            The marker size of the points. The default is 2.
        color : str or list-like
            Can be a single color (e.g. &#34;black&#34;, &#34;rgb(122, 15, 241)&#34;) or a colorbar list.
            Is ignored if `colorbar` is set to True. For more information, check the Plotly
            documentation. The default is None.
        opacity : float
            The opacity of the lines, where 0 is transparent and 1 is fully
            opaque. The default is 0.8.
        colorbar : bool
            If set to True, will color-code the data in the sample column `colorbar_col`.
            Overrides `color` if set to True. The default is False.
        colorbar_col : int
            The column in the data samples that will be used to color the points. Only has
            an effect if `colorbar` is set to True. The default is -1 (the last column).
        colorbar_title : str
            If set, the colorbar will have this title above. The default is None.

        Returns
        -------
        plotly.graph_objs.Scatter3d
            A Plotly trace of the points.

        &#39;&#39;&#39;

        # Check if sample_indices is an iterable collection (list-like)
        # otherwise just &#34;iterate&#34; over the single number
        if not hasattr(sample_indices, &#34;__iter__&#34;):
            sample_indices = [sample_indices]

        coords_x = []
        coords_y = []
        coords_z = []

        marker = dict(
            size = size,
            color = color,
            opacity = opacity
        )

        if colorbar:
            marker[&#39;color&#39;] = []
            marker.update(colorscale = &#34;Magma&#34;)

            if colorbar_title is not None:
                marker.update(colorbar = dict(title = colorbar_title))

        # For each selected sample include all the needed coordinates
        for n in sample_indices:
            sample = self[n]

            coords_x.extend(sample[:, 1])
            coords_y.extend(sample[:, 2])
            coords_z.extend(sample[:, 3])

            if colorbar == True:
                marker[&#39;color&#39;].extend(sample[:, colorbar_col])

        trace = go.Scatter3d(
            x = coords_x,
            y = coords_y,
            z = coords_z,
            mode = &#34;markers&#34;,
            marker = marker
        )

        return trace


    def __len__(self):
        # Defined so that len(class_instance) returns the number of samples.

        return self.number_of_samples


    def __str__(self):
        # Shown when calling print(class)
        docstr = &#34;&#34;

        docstr += &#34;number_of_points =  {}\n\n&#34;.format(self.number_of_points)
        docstr += &#34;sample_size =       {}\n&#34;.format(self._sample_size)
        docstr += &#34;overlap =           {}\n&#34;.format(self._overlap)
        docstr += &#34;number_of_samples = {}\n\n&#34;.format(self.number_of_samples)
        docstr += &#34;point_data = \n&#34;
        docstr += self._point_data.__str__()

        return docstr


    def __repr__(self):
        # Shown when writing the class on a REPR

        docstr = &#34;Class instance that inherits from `pept.PointData`.\n\n&#34; + self.__str__() + &#34;\n\n&#34;
        docstr += &#34;Particular cases:\n&#34;
        docstr += &#34; &gt; If sample_size == 0, all point_data is returned as one single sample.\n&#34;
        docstr += &#34; &gt; If overlap &gt;= sample_size, an error is raised.\n&#34;
        docstr += &#34; &gt; If overlap &lt; 0, points are skipped between samples.\n&#34;

        return docstr


    def __getitem__(self, key):
        # Defined so that samples can be accessed as class_instance[0]

        if self.number_of_samples == 0:
            raise IndexError(&#34;Tried to access sample {} (indexed from 0), when there are {} samples&#34;.format(key, self.number_of_samples))

        if key &gt;= self.number_of_samples:
            raise IndexError(&#34;Tried to access sample {} (indexed from 0), when there are {} samples&#34;.format(key, self.number_of_samples))


        while key &lt; 0:
            key += self.number_of_samples

        return self.sample_n(key + 1)


    def __iter__(self):
        # Defined so the class can be iterated as `for sample in class_instance: ...`
        return self


    def __next__(self):
        # sample_size = 0 =&gt; return all data
        if self._sample_size == 0:
            self._sample_size = -1
            return self._point_data
        # Use -1 as a flag
        if self._sample_size == -1:
            self._sample_size = 0
            raise StopIteration

        # sample_size &gt; 0 =&gt; return slices
        if self._index != 0:
            self._index = self._index + self._sample_size - self.overlap
        else:
            self._index = self._index + self.sample_size


        if self._index &gt; self.number_of_points:
            self._index = 0
            raise StopIteration

        return self._point_data[(self._index - self._sample_size):self._index]</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pept.tracking.peptml.peptml.Cutpoints" href="tracking/peptml/peptml.html#pept.tracking.peptml.peptml.Cutpoints">Cutpoints</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pept.PointData.number_of_points"><code class="name">var <span class="ident">number_of_points</span></code></dt>
<dd>
<section class="desc"><p>Get the number of points stored in the class.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The number of points stored in <code>point_data</code>.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def number_of_points(self):
    &#39;&#39;&#39;Get the number of points stored in the class.

    Returns
    -------
    int
        The number of points stored in `point_data`.

    &#39;&#39;&#39;
    return self._number_of_points</code></pre>
</details>
</dd>
<dt id="pept.PointData.number_of_samples"><code class="name">var <span class="ident">number_of_samples</span></code></dt>
<dd>
<section class="desc"><p>Get number of samples, considering overlap.</p>
<p>If <code>sample_size == 0</code>, all data is returned as a single sample,
and so <code>number_of_samples</code> will be 1. Otherwise, it checks the
number of samples every time it is called, taking <code>overlap</code> into
consideration.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The number of samples, taking <code>overlap</code> into consideration.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def number_of_samples(self):
    &#39;&#39;&#39;Get number of samples, considering overlap.

    If `sample_size == 0`, all data is returned as a single sample,
    and so `number_of_samples` will be 1. Otherwise, it checks the
    number of samples every time it is called, taking `overlap` into
    consideration.

    Returns
    -------
    int
        The number of samples, taking `overlap` into consideration.

    &#39;&#39;&#39;
    # If self.sample_size == 0, all data is returned as a single sample
    if self._sample_size == 0:
        return 1

    # If self.sample_size != 0, check there is at least one sample
    if self._number_of_points &gt;= self._sample_size:
        return (self._number_of_points - self._sample_size) // (self.sample_size - self.overlap) + 1
    else:
        return 0</code></pre>
</details>
</dd>
<dt id="pept.PointData.overlap"><code class="name">var <span class="ident">overlap</span></code></dt>
<dd>
<section class="desc"><p>Get the overlap between every two samples returned by the class.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The overlap (number of points) between every two samples
returned by
the class.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def overlap(self):
    &#39;&#39;&#39;Get the overlap between every two samples returned by the class.

    Returns
    -------
    int
        The overlap (number of points) between every two samples  returned by
        the class.

    &#39;&#39;&#39;

    return self._overlap</code></pre>
</details>
</dd>
<dt id="pept.PointData.point_data"><code class="name">var <span class="ident">point_data</span></code></dt>
<dd>
<section class="desc"><p>Get the points stored in the class.</p>
<h2 id="returns">Returns</h2>
<p>(M, N) numpy.ndarray
A memory view of the points stored in <code>point_data</code>.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def point_data(self):
    &#39;&#39;&#39;Get the points stored in the class.

    Returns
    -------
    (M, N) numpy.ndarray
        A memory view of the points stored in `point_data`.

    &#39;&#39;&#39;

    return self._point_data</code></pre>
</details>
</dd>
<dt id="pept.PointData.sample_size"><code class="name">var <span class="ident">sample_size</span></code></dt>
<dd>
<section class="desc"><p>Get the number of points in one sample returned by the class.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The sample size (number of lines) in one sample returned by
the class.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def sample_size(self):
    &#39;&#39;&#39;Get the number of points in one sample returned by the class.

    Returns
    -------
    int
        The sample size (number of lines) in one sample returned by
        the class.

    &#39;&#39;&#39;

    return self._sample_size</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pept.PointData.all_points_trace"><code class="name flex">
<span>def <span class="ident">all_points_trace</span></span>(<span>self, size=2, color=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Get a Plotly trace of all points.</p>
<p>Creates a <code>plotly.graph_objects.Scatter3d</code> object. Can
then be passed to the <code>plotly.graph_objects.figure.add_trace</code>
function or a <code>PlotlyGrapher</code> instance using the <code>add_trace</code> method.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>plotly.graph_objects.Scatter3d</code></dt>
<dd>A <code>plotly.graph_objects.Scatter3d</code> trace of all points.</dd>
</dl>
<h2 id="note">Note</h2>
<p>Plotting all points in the case of large LoR arrays is <em>very</em>
computationally intensive. For large arrays (&gt; 10000), plotting
individual samples using <code>points_sample_n_traces</code> is recommended.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def all_points_trace(self, size = 2, color = None):
    &#39;&#39;&#39;Get a Plotly trace of all points.

    Creates a `plotly.graph_objects.Scatter3d` object. Can
    then be passed to the `plotly.graph_objects.figure.add_trace`
    function or a `PlotlyGrapher` instance using the `add_trace` method.

    Returns
    -------
    plotly.graph_objects.Scatter3d
        A `plotly.graph_objects.Scatter3d` trace of all points.

    Note
    ----
    Plotting all points in the case of large LoR arrays is *very*
    computationally intensive. For large arrays (&gt; 10000), plotting
    individual samples using `points_sample_n_traces` is recommended.

    &#39;&#39;&#39;

    trace = go.Scatter3d(
        x = self._point_data[:, 1],
        y = self._point_data[:, 2],
        z = self._point_data[:, 3],
        mode = &#39;markers&#39;,
        marker = dict(
            size = size,
            color = color,
            opacity = 0.8
        )
    )

    return trace</code></pre>
</details>
</dd>
<dt id="pept.PointData.all_points_trace_colorbar"><code class="name flex">
<span>def <span class="ident">all_points_trace_colorbar</span></span>(<span>self, size=2, colorbar_title=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Get a Plotly trace of all points, colour-coding the last column of <code>point_data</code>.</p>
<p>Creates a <code>plotly.graph_objects.Scatter3d</code> object. Can
then be passed to the <code>plotly.graph_objects.figure.add_trace</code>
function or a <code>PlotlyGrapher</code> instance using the <code>add_trace</code> method.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>plotly.graph_objects.Scatter3d</code></dt>
<dd>A <code>plotly.graph_objects.Scatter3d</code> trace of all points.</dd>
</dl>
<h2 id="note">Note</h2>
<p>Plotting all points in the case of large LoR arrays is <em>very</em>
computationally intensive. For large arrays (&gt; 10000), plotting
individual samples using <code>points_sample_n_traces</code> is recommended.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def all_points_trace_colorbar(self, size = 2, colorbar_title = None):
    &#39;&#39;&#39;Get a Plotly trace of all points, colour-coding the last column of `point_data`.

    Creates a `plotly.graph_objects.Scatter3d` object. Can
    then be passed to the `plotly.graph_objects.figure.add_trace`
    function or a `PlotlyGrapher` instance using the `add_trace` method.

    Returns
    -------
    plotly.graph_objects.Scatter3d
        A `plotly.graph_objects.Scatter3d` trace of all points.

    Note
    ----
    Plotting all points in the case of large LoR arrays is *very*
    computationally intensive. For large arrays (&gt; 10000), plotting
    individual samples using `points_sample_n_traces` is recommended.

    &#39;&#39;&#39;

    if colorbar_title != None:
        colorbar = dict(title = colorbar_title)
    else:
        colorbar = dict()

    trace = go.Scatter3d(
        x = self._point_data[:, 1],
        y = self._point_data[:, 2],
        z = self._point_data[:, 3],
        mode = &#39;markers&#39;,
        marker = dict(
            size = size,
            color = self._point_data[:, -1],
            colorscale = &#39;Magma&#39;,
            colorbar = colorbar,
            opacity = 0.8
        )
    )

    return trace</code></pre>
</details>
</dd>
<dt id="pept.PointData.plot_all_points"><code class="name flex">
<span>def <span class="ident">plot_all_points</span></span>(<span>self, ax=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Plot all points using matplotlib</p>
<p>Given a <strong>mpl_toolkits.mplot3d.Axes3D</strong> axis, plots all points on it.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>mpl_toolkits.mplot3D.Axes3D</code> <code>object</code></dt>
<dd>The 3D matplotlib-based axis for plotting.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong>, <strong><code>ax</code></strong> :&ensp;<code>matplotlib</code> <code>figure</code> <code>and</code> <code>axes</code> <code>objects</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="note">Note</h2>
<p>Plotting all points in the case of large LoR arrays is <em>very</em>
computationally intensive. For large arrays (&gt; 10000), plotting
individual samples using <code>plot_points_sample_n</code> is recommended.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def plot_all_points(self, ax = None):
    &#39;&#39;&#39;Plot all points using matplotlib

    Given a **mpl_toolkits.mplot3d.Axes3D** axis, plots all points on it.

    Parameters
    ----------
    ax : mpl_toolkits.mplot3D.Axes3D object
        The 3D matplotlib-based axis for plotting.

    Returns
    -------
    fig, ax : matplotlib figure and axes objects

    Note
    ----
    Plotting all points in the case of large LoR arrays is *very*
    computationally intensive. For large arrays (&gt; 10000), plotting
    individual samples using `plot_points_sample_n` is recommended.

    &#39;&#39;&#39;

    if ax == None:
        fig = plt.figure()
        ax  = fig.add_subplot(111, projection=&#39;3d&#39;)
    else:
        fig = plt.gcf()

    # Scatter x, y, z, [color]

    x = self._point_data[:, 1],
    y = self._point_data[:, 2],
    z = self._point_data[:, 3],

    color = self._point_data[:, -1],

    cmap = plt.cm.magma
    color_array = cmap(colour_data)

    ax.scatter(x,y,z,c=color_array[0])

    return fig, ax</code></pre>
</details>
</dd>
<dt id="pept.PointData.plot_all_points_alt_axes"><code class="name flex">
<span>def <span class="ident">plot_all_points_alt_axes</span></span>(<span>self, ax=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Plot all points using matplotlib on PEPT-style axes</p>
<p>Given a <strong>mpl_toolkits.mplot3d.Axes3D</strong> axis, plots all points on
the PEPT-style convention: <strong>x</strong> is <em>parallel and horizontal</em> to the
screens, <strong>y</strong> is <em>parallel and vertical</em> to the screens, <strong>z</strong> is
<em>perpendicular</em> to the screens. The mapping relative to the
Cartesian coordinates would then be: (x, y, z) -&gt; (z, x, y)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>mpl_toolkits.mplot3D.Axes3D</code> <code>object</code></dt>
<dd>The 3D matplotlib-based axis for plotting.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong>, <strong><code>ax</code></strong> :&ensp;<code>matplotlib</code> <code>figure</code> <code>and</code> <code>axes</code> <code>objects</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="note">Note</h2>
<p>Plotting all points in the case of large LoR arrays is <em>very</em>
computationally intensive. For large arrays (&gt; 10000), plotting
individual samples using <code>plot_lines_sample_n_alt_axes</code> is recommended.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def plot_all_points_alt_axes(self, ax = None ):
    &#39;&#39;&#39;Plot all points using matplotlib on PEPT-style axes

    Given a **mpl_toolkits.mplot3d.Axes3D** axis, plots all points on
    the PEPT-style convention: **x** is *parallel and horizontal* to the
    screens, **y** is *parallel and vertical* to the screens, **z** is
    *perpendicular* to the screens. The mapping relative to the
    Cartesian coordinates would then be: (x, y, z) -&gt; (z, x, y)

    Parameters
    ----------
    ax : mpl_toolkits.mplot3D.Axes3D object
        The 3D matplotlib-based axis for plotting.

    Returns
    -------
    fig, ax : matplotlib figure and axes objects

    Note
    ----
    Plotting all points in the case of large LoR arrays is *very*
    computationally intensive. For large arrays (&gt; 10000), plotting
    individual samples using `plot_lines_sample_n_alt_axes` is recommended.

    &#39;&#39;&#39;

    if ax == None:
        fig = plt.figure()
        ax  = fig.add_subplot(111, projection=&#39;3d&#39;)
    else:
        fig = plt.gcf()

    # Scatter x, y, z, [color]

    x = self._point_data[:, 1]
    y = self._point_data[:, 2]
    z = self._point_data[:, 3]

    color = self._point_data[:, -1]

    cmap = plt.cm.magma
    color_array = cmap(color)

    ax.scatter(z,x,y,c=color_array[0])

    return fig, ax</code></pre>
</details>
</dd>
<dt id="pept.PointData.plot_points_sample_n"><code class="name flex">
<span>def <span class="ident">plot_points_sample_n</span></span>(<span>self, n, ax=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Plot points from sample <code>n</code> using matplotlib</p>
<p>Given a <strong>mpl_toolkits.mplot3d.Axes3D</strong> axis, plots all points
from sample number <code>n</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>mpl_toolkits.mplot3D.Axes3D</code> <code>object</code></dt>
<dd>The 3D matplotlib-based axis for plotting.</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of the sample to be plotted.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong>, <strong><code>ax</code></strong> :&ensp;<code>matplotlib</code> <code>figure</code> <code>and</code> <code>axes</code> <code>objects</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def plot_points_sample_n(self, n, ax=None):
    &#39;&#39;&#39;Plot points from sample `n` using matplotlib

    Given a **mpl_toolkits.mplot3d.Axes3D** axis, plots all points
    from sample number `n`.

    Parameters
    ----------
    ax : mpl_toolkits.mplot3D.Axes3D object
        The 3D matplotlib-based axis for plotting.
    n : int
        The number of the sample to be plotted.

    Returns
    -------

    fig, ax : matplotlib figure and axes objects

    &#39;&#39;&#39;

    if ax == None:
        fig = plt.figure()
        ax  = fig.add_subplot(111, projection=&#39;3d&#39;)
    else:
        fig = plt.gcf()

    # Scatter x, y, z, [color]

    sample = self.sample_n(n)

    x = sample[:, 1]
    y = sample[:, 2]
    z = sample[:, 3]

    color = sample[:, -1]

    cmap = plt.cm.magma
    color_array = cmap(color)

    ax.scatter(z,x,y,c=color_array[0])

    return fig, ax</code></pre>
</details>
</dd>
<dt id="pept.PointData.plot_points_sample_n_alt_axes"><code class="name flex">
<span>def <span class="ident">plot_points_sample_n_alt_axes</span></span>(<span>self, n, ax=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Plot points from sample <code>n</code> using matplotlib on PEPT-style axes</p>
<p>Given a <strong>mpl_toolkits.mplot3d.Axes3D</strong> axis, plots all points from
sample number sampleN on the PEPT-style coordinates convention:
<strong>x</strong> is <em>parallel and horizontal</em> to the screens, <strong>y</strong> is
<em>parallel and vertical</em> to the screens, <strong>z</strong> is <em>perpendicular</em>
to the screens. The mapping relative to the Cartesian coordinates
would then be: (x, y, z) -&gt; (z, x, y)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>mpl_toolkits.mplot3D.Axes3D</code> <code>object</code></dt>
<dd>The 3D matplotlib-based axis for plotting.</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of the sample to be plotted.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong>, <strong><code>ax</code></strong> :&ensp;<code>matplotlib</code> <code>figure</code> <code>and</code> <code>axes</code> <code>objects</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def plot_points_sample_n_alt_axes(self, n, ax=None):
    &#39;&#39;&#39;Plot points from sample `n` using matplotlib on PEPT-style axes

    Given a **mpl_toolkits.mplot3d.Axes3D** axis, plots all points from
    sample number sampleN on the PEPT-style coordinates convention:
    **x** is *parallel and horizontal* to the screens, **y** is
    *parallel and vertical* to the screens, **z** is *perpendicular*
    to the screens. The mapping relative to the Cartesian coordinates
    would then be: (x, y, z) -&gt; (z, x, y)

    Parameters
    ----------
    ax : mpl_toolkits.mplot3D.Axes3D object
        The 3D matplotlib-based axis for plotting.
    n : int
        The number of the sample to be plotted.

    Returns
    -------

    fig, ax : matplotlib figure and axes objects
    &#39;&#39;&#39;

    if ax == None:
        fig = plt.figure()
        ax  = fig.add_subplot(111, projection=&#39;3d&#39;)
    else:
        fig = plt.gcf()

    # Scatter x, y, z, [color]

    sample = self.sample_n(n)

    x = sample[:, 1]
    y = sample[:, 2]
    z = sample[:, 3]

    color = sample[:, -1]

    cmap = plt.cm.magma
    color_array = cmap(color)

    ax.scatter(z,x,y,c=color_array[0])

    return fig, ax</code></pre>
</details>
</dd>
<dt id="pept.PointData.points_sample_n_trace"><code class="name flex">
<span>def <span class="ident">points_sample_n_trace</span></span>(<span>self, n, size=2, color=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Get a Plotly trace for all points in sample <code>n</code>.</p>
<p>Returns a <code>plotly.graph_objects.Scatter3d</code> trace containing all points
included in sample number <code>n</code>.
Can then be passed to the <code>plotly.graph_objects.figure.add_trace</code>
function or a <code>PlotlyGrapher</code> instance using the <code>add_trace</code> method.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of the sample to be plotted.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>plotly.graph_object.Scatter3d</code></dt>
<dd>A <code>plotly.graph_objects.Scatter3d</code> trace of all points in sample <code>n</code>.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def points_sample_n_trace(self, n, size = 2, color = None):
    &#39;&#39;&#39;Get a Plotly trace for all points in sample `n`.

    Returns a `plotly.graph_objects.Scatter3d` trace containing all points
    included in sample number `n`.
    Can then be passed to the `plotly.graph_objects.figure.add_trace`
    function or a `PlotlyGrapher` instance using the `add_trace` method.

    Parameters
    ----------
    n : int
        The number of the sample to be plotted.

    Returns
    -------
    plotly.graph_object.Scatter3d
        A `plotly.graph_objects.Scatter3d` trace of all points in sample `n`.

    &#39;&#39;&#39;

    sample = self.sample_n(n)
    trace = go.Scatter3d(
        x = sample[:, 1],
        y = sample[:, 2],
        z = sample[:, 3],
        mode = &#39;markers&#39;,
        marker = dict(
            size = size,
            color = color,
            opacity = 0.8
        )
    )

    return trace</code></pre>
</details>
</dd>
<dt id="pept.PointData.points_sample_n_trace_colorbar"><code class="name flex">
<span>def <span class="ident">points_sample_n_trace_colorbar</span></span>(<span>self, n, size=2, colorbar_title=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Get a Plotly trace for all points in sample <code>n</code>, colour-coding the last column.</p>
<p>Returns a <code>plotly.graph_objects.Scatter3d</code> trace containing all points
included in sample number <code>n</code>.
Can then be passed to the <code>plotly.graph_objects.figure.add_trace</code>
function or a <code>PlotlyGrapher</code> instance using the <code>add_trace</code> method.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of the sample to be plotted.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>plotly.graph_object.Scatter3d</code></dt>
<dd>A <code>plotly.graph_objects.Scatter3d</code> trace of all points in sample <code>n</code>.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def points_sample_n_trace_colorbar(self, n, size = 2, colorbar_title = None):
    &#39;&#39;&#39;Get a Plotly trace for all points in sample `n`, colour-coding the last column.

    Returns a `plotly.graph_objects.Scatter3d` trace containing all points
    included in sample number `n`.
    Can then be passed to the `plotly.graph_objects.figure.add_trace`
    function or a `PlotlyGrapher` instance using the `add_trace` method.

    Parameters
    ----------
    n : int
        The number of the sample to be plotted.

    Returns
    -------
    plotly.graph_object.Scatter3d
        A `plotly.graph_objects.Scatter3d` trace of all points in sample `n`.

    &#39;&#39;&#39;

    if colorbar_title != None:
        colorbar = dict(title = colorbar_title)
    else:
        colorbar = dict()

    sample = self.sample_n(n)
    trace = go.Scatter3d(
        x = sample[:, 1],
        y = sample[:, 2],
        z = sample[:, 3],
        mode = &#39;markers&#39;,
        marker = dict(
            size = size,
            color = sample[:, -1],
            colorscale = &#39;Magma&#39;,
            colorbar = colorbar,
            opacity = 0.8
        )
    )

    return trace</code></pre>
</details>
</dd>
<dt id="pept.PointData.points_trace"><code class="name flex">
<span>def <span class="ident">points_trace</span></span>(<span>self, sample_indices=0, size=2, color=None, opacity=0.8, colorbar=False, colorbar_col=-1, colorbar_title=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Get a Plotly trace for all points in selected samples, with possible color-coding.</p>
<p>Returns a <code>plotly.graph_objects.Scatter3d</code> trace containing all points
included in in the samples selected by <code>sample_indices</code>. <code>sample_indices</code>
can be a single sample index (e.g. 0) or an iterable of indices (e.g.
[1,5,6]).
Can then be passed to the <code>plotly.graph_objects.figure.add_trace</code>
function or a <code>PlotlyGrapher</code> instance using the <code>add_trace</code> method.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>sample_indices</code></strong> :&ensp;<code>int</code> or <code>iterable</code></dt>
<dd>The index or indices of the samples of LoRs. The default is 0 (the first sample).</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>float</code></dt>
<dd>The marker size of the points. The default is 2.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code> or <code>list</code>-<code>like</code></dt>
<dd>Can be a single color (e.g. "black", "rgb(122, 15, 241)") or a colorbar list.
Is ignored if <code>colorbar</code> is set to True. For more information, check the Plotly
documentation. The default is None.</dd>
<dt><strong><code>opacity</code></strong> :&ensp;<code>float</code></dt>
<dd>The opacity of the lines, where 0 is transparent and 1 is fully
opaque. The default is 0.8.</dd>
<dt><strong><code>colorbar</code></strong> :&ensp;<code>bool</code></dt>
<dd>If set to True, will color-code the data in the sample column <code>colorbar_col</code>.
Overrides <code>color</code> if set to True. The default is False.</dd>
<dt><strong><code>colorbar_col</code></strong> :&ensp;<code>int</code></dt>
<dd>The column in the data samples that will be used to color the points. Only has
an effect if <code>colorbar</code> is set to True. The default is -1 (the last column).</dd>
<dt><strong><code>colorbar_title</code></strong> :&ensp;<code>str</code></dt>
<dd>If set, the colorbar will have this title above. The default is None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>plotly.graph_objs.Scatter3d</code></dt>
<dd>A Plotly trace of the points.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def points_trace(
    self,
    sample_indices = 0,
    size = 2,
    color = None,
    opacity = 0.8,
    colorbar = False,
    colorbar_col = -1,
    colorbar_title = None
):
    &#39;&#39;&#39;Get a Plotly trace for all points in selected samples, with possible color-coding.

    Returns a `plotly.graph_objects.Scatter3d` trace containing all points
    included in in the samples selected by `sample_indices`. `sample_indices`
    can be a single sample index (e.g. 0) or an iterable of indices (e.g.
    [1,5,6]).
    Can then be passed to the `plotly.graph_objects.figure.add_trace`
    function or a `PlotlyGrapher` instance using the `add_trace` method.

    Parameters
    ----------
    sample_indices : int or iterable
        The index or indices of the samples of LoRs. The default is 0 (the first sample).
    size : float
        The marker size of the points. The default is 2.
    color : str or list-like
        Can be a single color (e.g. &#34;black&#34;, &#34;rgb(122, 15, 241)&#34;) or a colorbar list.
        Is ignored if `colorbar` is set to True. For more information, check the Plotly
        documentation. The default is None.
    opacity : float
        The opacity of the lines, where 0 is transparent and 1 is fully
        opaque. The default is 0.8.
    colorbar : bool
        If set to True, will color-code the data in the sample column `colorbar_col`.
        Overrides `color` if set to True. The default is False.
    colorbar_col : int
        The column in the data samples that will be used to color the points. Only has
        an effect if `colorbar` is set to True. The default is -1 (the last column).
    colorbar_title : str
        If set, the colorbar will have this title above. The default is None.

    Returns
    -------
    plotly.graph_objs.Scatter3d
        A Plotly trace of the points.

    &#39;&#39;&#39;

    # Check if sample_indices is an iterable collection (list-like)
    # otherwise just &#34;iterate&#34; over the single number
    if not hasattr(sample_indices, &#34;__iter__&#34;):
        sample_indices = [sample_indices]

    coords_x = []
    coords_y = []
    coords_z = []

    marker = dict(
        size = size,
        color = color,
        opacity = opacity
    )

    if colorbar:
        marker[&#39;color&#39;] = []
        marker.update(colorscale = &#34;Magma&#34;)

        if colorbar_title is not None:
            marker.update(colorbar = dict(title = colorbar_title))

    # For each selected sample include all the needed coordinates
    for n in sample_indices:
        sample = self[n]

        coords_x.extend(sample[:, 1])
        coords_y.extend(sample[:, 2])
        coords_z.extend(sample[:, 3])

        if colorbar == True:
            marker[&#39;color&#39;].extend(sample[:, colorbar_col])

    trace = go.Scatter3d(
        x = coords_x,
        y = coords_y,
        z = coords_z,
        mode = &#34;markers&#34;,
        marker = marker
    )

    return trace</code></pre>
</details>
</dd>
<dt id="pept.PointData.sample_n"><code class="name flex">
<span>def <span class="ident">sample_n</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<section class="desc"><p>Get sample number n (indexed from 1, i.e. <code>n &gt; 0</code>)</p>
<p>Returns the lines from <code>point_data</code> included in sample number
<code>n</code>. Samples are numbered starting from 1.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of the sample required. Note that <code>1 &lt;= n &lt;=
number_of_samples</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>(M, N) numpy.ndarray
A shallow copy of the points from <code>point_data</code> included in
sample number n.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>IndexError</code></dt>
<dd>If <code>sample_size == 0</code>, all data is returned as one single
sample. Raised if <code>n</code> is not 1.</dd>
<dt><code>IndexError</code></dt>
<dd>If <code>n &gt; number_of_samples</code> or <code>n &lt;= 0</code>.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def sample_n(self, n):
    &#39;&#39;&#39;Get sample number n (indexed from 1, i.e. `n &gt; 0`)

    Returns the lines from `point_data` included in sample number
    `n`. Samples are numbered starting from 1.

    Parameters
    ----------
    n : int
        The number of the sample required. Note that `1 &lt;= n &lt;=
        number_of_samples`.

    Returns
    -------
    (M, N) numpy.ndarray
        A shallow copy of the points from `point_data` included in
        sample number n.

    Raises
    ------
    IndexError
        If `sample_size == 0`, all data is returned as one single
        sample. Raised if `n` is not 1.
    IndexError
        If `n &gt; number_of_samples` or `n &lt;= 0`.

    &#39;&#39;&#39;
    if self._sample_size == 0:
        if n == 1:
            return self._point_data
        else:
            raise IndexError(&#34;\n\n[ERROR]: Trying to access a non-existent sample (samples indexed from 1): asked for sample number {}, when there is only 1 sample (sample_size == 0)\n&#34;.format(n))
    elif (n &gt; self.number_of_samples) or n &lt;= 0:
        raise IndexError(&#34;\n\n[ERROR]: Trying to access a non-existent sample (samples are indexed from 1): asked for sample number {}, when there are {} samples\n&#34;.format(n, self.number_of_samples))

    start_index = (n - 1) * (self._sample_size - self._overlap)
    return self._point_data[start_index:(start_index + self._sample_size)]</code></pre>
</details>
</dd>
<dt id="pept.PointData.to_csv"><code class="name flex">
<span>def <span class="ident">to_csv</span></span>(<span>self, filepath, delimiter='
', newline='\n')</span>
</code></dt>
<dd>
<section class="desc"><p>Write <code>point_data</code> to a CSV file</p>
<pre><code>    Write all points (and any extra data) stored in the class to a CSV file.

    Parameters
    ----------
        filepath : filename or file handle
            If filepath is a path (rather than file handle), it is relative
            to where python is called.
        delimiter : str, optional
            The delimiter between values. The default is two spaces '  ',
            such that numbers in the format '123,456.78' are well-understood.
        newline : str, optional
            The sequence of characters at the end of every line. The default
            is a new line '
</code></pre>
<p>'</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def to_csv(self, filepath, delimiter = &#39;  &#39;, newline = &#39;\n&#39;):
    &#39;&#39;&#39;Write `point_data` to a CSV file

    Write all points (and any extra data) stored in the class to a CSV file.

    Parameters
    ----------
        filepath : filename or file handle
            If filepath is a path (rather than file handle), it is relative
            to where python is called.
        delimiter : str, optional
            The delimiter between values. The default is two spaces &#39;  &#39;,
            such that numbers in the format &#39;123,456.78&#39; are well-understood.
        newline : str, optional
            The sequence of characters at the end of every line. The default
            is a new line &#39;\n&#39;

    &#39;&#39;&#39;
    np.savetxt(filepath, self._point_data, delimiter = delimiter, newline = newline)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pept.VoxelData"><code class="flex name class">
<span>class <span class="ident">VoxelData</span></span>
<span>(</span><span>line_data, volume_limits=[500.0, 500.0, 500.0], number_of_voxels=[10, 10, 10], traverse=True, verbose=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class VoxelData:


    def __init__(
        self,
        line_data,
        volume_limits = [500., 500., 500.],
        number_of_voxels = [10, 10, 10],
        traverse = True,
        verbose = False
    ):

        if verbose:
            start = time.time()

        # If `line_data` is not C-contiguous, create a C-contiguous copy
        self._line_data = np.asarray(line_data, order = &#39;C&#39;, dtype = float)
        # Check that line_data has shape (N, 7)
        if self._line_data.ndim != 2 or self._line_data.shape[1] != 7:
            raise ValueError(&#39;\n[ERROR]: line_data should have dimensions (N, 7). Received {}\n&#39;.format(self._line_data.shape))

        self._number_of_lines = len(self._line_data)

        # If `volume_limits` is not C-contiguous, create a C-contiguous copy
        self._volume_limits = np.asarray(volume_limits, dtype = float, order = &#34;C&#34;)
        # Check that volume_limits has shape (3,)
        if self._volume_limits.ndim != 1 or self._volume_limits.shape[0] != 3:
            raise ValueError(&#34;\n[ERROR]: volume_limits should have dimensions (3,). Received {}\n&#34;.format(self._volume_limits.shape))

        # If `number_of_voxels` is not C-contiguous, create a C-contiguous copy
        self._number_of_voxels = np.asarray(number_of_voxels, dtype = int, order = &#34;C&#34;)
        # Check that number_of_voxels has shape(3,)
        if self._number_of_voxels.ndim != 1 or self._number_of_voxels.shape[0] != 3:
            raise ValueError(&#34;\n[ERROR]: number_of_voxels should have dimensions (3,). Received {}\n&#34;.format(self._number_of_voxels.shape))

        self._voxel_sizes = self._volume_limits / self._number_of_voxels

        # If, for dimension x, there are 5 voxels between coordinates 0
        # and 5, then the delimiting grid is [0, 1, 2, 3, 4, 5].
        self._voxel_grid = [np.linspace(0, self._volume_limits[i], self._number_of_voxels[i] + 1) for i in range(3)]

        # All access to voxel_positions will be done directly through the inner
        # class _VoxelPositions, so no need for a private property here
        self.voxel_positions = self._VoxelPositions(self._volume_limits, self._number_of_voxels)
        self._voxel_data = np.zeros(self._number_of_voxels, dtype = int)

        if traverse:
            if verbose:
                start_traverse = time.time()

            if traverse == True:
                self.traverse()
            else:
                self.traverse(traverse)

            if verbose:
                end_traverse = time.time()

        if verbose:
            end = time.time()
            print(&#34;Initialising the instance of VoxelData took {} seconds.\n&#34;.format(end - start))
            if traverse:
                print(&#34;Traversing all voxels took {} seconds.\n&#34;.format(end_traverse - start_traverse))


    class _VoxelPositions:

        def __init__(self, volume_limits, number_of_voxels):

            self.volume_limits = np.asarray(volume_limits, dtype = float, order = &#34;C&#34;)
            self.number_of_voxels = np.asarray(number_of_voxels, dtype = int, order = &#34;C&#34;)
            self.voxel_sizes = self.volume_limits / self.number_of_voxels

            self._index = 0


        def at(self, ix, iy, iz):
            # Evaluate the position of the voxel (the centre of it) at indices
            # [ix, iy, iz]

            indices = np.array([ix, iy, iz], dtype = int)

            if (indices &gt;= self.number_of_voxels).any() or (indices &lt; 0).any():
                raise IndexError(&#34;[ERROR]: Each of the [ix, iy, iz] indices must be between 0 and the corresponding `number_of_voxels`.&#34;)

            return self._at(indices)


        def _at(self, indices):
            # Unchecked!
            return self.voxel_sizes * (0.5 + indices)


        def at_corner(self, ix, iy, iz):
            # Evaluate the position of the voxel (the corner of it) at indices
            # [ix, iy, iz]

            indices = np.array([ix, iy, iz], dtype = int)

            if (indices &gt;= self.number_of_voxels).any() or (indices &lt; 0).any():
                raise IndexError(&#34;[ERROR]: Each of the [ix, iy, iz] indices must be between 0 and the corresponding `number_of_voxels`.&#34;)

            return self._at_corner(indices)


        def _at_corner(self, indices):
            # Unchecked!
            return self.voxel_sizes * indices


        def all(self):

            positions = []
            for i in range(self.number_of_voxels[0]):
                for j in range(self.number_of_voxels[1]):
                    for k in range(self.number_of_voxels[2]):
                        positions.append(self._at(np.array([i, j, k])))

            return np.array(positions)


        def __len__(self):
            return self.number_of_voxels[0]


        def __getitem__(self, key):

            if not isinstance(key, tuple):
                key = (key,)

            if len(key) &gt; 3:
                raise ValueError(&#34;[ERROR]: The accessor takes maximum 3 indices, {} were given.&#34;.format(len(key)))

            # Calculate the starting and ending indices and the step for the
            # [x, y, z] coordinates of all the elements that are accessed.
            # The default (:, :, :) is the whole range.
            start = [0, 0, 0]
            stop = list(self.number_of_voxels)
            step = [1, 1, 1]

            # The ranges of data selection for each dimension. Default is a
            # range, but can be an explicit list too (e.g. select elements
            # [1,2,5]).
            xyz_ranges = [range(stop[i]) for i in range(3)]

            # Handles negative indices for each of the 3 dimensions.
            def make_positive(index, dimension):
                while index &lt; 0:
                    index += self.number_of_voxels[dimension]
                return index

            # Interpret each key
            for i in range(len(key)):
                # If key[i] is an int, only access the elements at that index,
                # equivalent to range(key[i], key[i] + 1, 1).
                if isinstance(key[i], (int, np.integer)):
                    if key[i] &gt;= self.number_of_voxels[i]:
                        raise IndexError(&#34;[ERROR]: Tried to access voxel number {} (indexed from 0), when there are {} voxels for dimension {}.&#34;.format(key[i], self.number_of_voxels[i], i))

                    index = make_positive(key[i], i)
                    start[i] = index
                    stop[i] = index + 1

                    xyz_ranges[i] = range(start[i], stop[i], step[i])

                # Interpret the possible slices (1:5, ::-1, etc.).
                elif isinstance(key[i], slice):
                    # First interpret the step for the ::-1 corner case.
                    if key[i].step is not None:
                        if not isinstance(key[i].step, (int, np.integer)):
                            raise TypeError(&#34;Slice step must be an int. Received {}.&#34;.format(type(key[i].step)))
                        if key[i].step == 0:
                            raise ValueError(&#34;Slice step cannot be zero.&#34;)
                        elif key[i].step &lt; 0:
                            # If the step is negative, the default start and
                            # stop become (max_index - 1) and -1, such that
                            # ::-1 works.
                            start[i] = self.number_of_voxels[i] - 1
                            stop[i] = -1
                            step[i] = key[i].step
                        else:
                            step[i] = key[i].step

                    if key[i].start is not None:
                        if not isinstance(key[i].start, (int, np.integer)):
                            raise TypeError(&#34;Slice start must be an int. Received {}.&#34;.format(type(key[i].start)))
                        # Corner case: x = [1,2,3] =&gt; x[5:10] == []
                        start[i] = min(make_positive(key[i].start, i), self.number_of_voxels[i])

                    if key[i].stop is not None:
                        if not isinstance(key[i].stop, (int, np.integer)):
                            raise TypeError(&#34;Slice stop must be an int. Received {}.&#34;.format(type(key[i].stop)))
                        # Corner case: x = [1,2,3] =&gt; x[5:10] == []
                        stop[i] = min(make_positive(key[i].stop, i), self.number_of_voxels[i])

                    xyz_ranges[i] = range(start[i], stop[i], step[i])

                # Interpret iterable sequence of selected elements
                elif hasattr(key[i], &#34;__iter__&#34;):
                    xyz_ranges[i] = np.asarray(key[i], dtype = int)

                else:
                    raise TypeError(&#34;Indices must be either `int`, `slice` or iterable of `int`s. Received {}.&#34;.format(type(key[i])))

            positions = []
            # Iterate through all the elements that need to be accessed
            for x in xyz_ranges[0]:
                for y in xyz_ranges[1]:
                    for z in xyz_ranges[2]:
                        positions.append(self._at(np.array([x, y, z])))

            if len(positions) == 1:
                return positions[0]
            else:
                return np.array(positions)


        def __iter__(self):
            return self


        def __next__(self):
            if self._index &gt;= len(self):
                self._index = 0
                raise StopIteration

            self._index += 1
            return self[self._index - 1]


    @property
    def line_data(self):
        return self._line_data


    @property
    def number_of_lines(self):
        return self._number_of_lines


    @property
    def volume_limits(self):
        return self._volume_limits


    @volume_limits.setter
    def volume_limits(self, volume_limits):
        # If `volume_limits` is not C-contiguous, create a C-contiguous copy
        self._volume_limits = np.asarray(volume_limits, dtype = float, order = &#34;C&#34;)
        # Check that volume_limits has shape (3,)
        if self._volume_limits.ndim != 1 or self._volume_limits.shape[0] != 3:
            raise ValueError(&#34;\n[ERROR]: volume_limits should have dimensions (3,). Received {}\n&#34;.format(self._volume_limits.shape))

        self._voxel_sizes = self._volume_limits / self._number_of_voxels

        # If, for dimension x, there are 5 voxels between coordinates 0
        # and 5, then the delimiting grid is [0, 1, 2, 3, 4, 5].
        self._voxel_grid = [np.linspace(0, self._volume_limits[i], self._number_of_voxels[i] + 1) for i in range(3)]

        # All access to voxel_positions will be done directly through the inner
        # class _VoxelPositions, so no need for a private property here
        self.voxel_positions = self._VoxelPositions(self._volume_limits, self._number_of_voxels)
        self._voxel_data = np.zeros(self._number_of_voxels, dtype = int)


    @property
    def number_of_voxels(self):
        return self._number_of_voxels


    @number_of_voxels.setter
    def number_of_voxels(self, number_of_voxels):
        # If `number_of_voxels` is not C-contiguous, create a C-contiguous copy
        self._number_of_voxels = np.asarray(number_of_voxels, dtype = int, order = &#34;C&#34;)
        # Check that number_of_voxels has shape(3,)
        if self._number_of_voxels.ndim != 1 or self._number_of_voxels.shape[0] != 3:
            raise ValueError(&#34;\n[ERROR]: number_of_voxels should have dimensions (3,). Received {}\n&#34;.format(self._number_of_voxels.shape))

        self._voxel_sizes = self._volume_limits / self._number_of_voxels

        # If, for dimension x, there are 5 voxels between coordinates 0
        # and 5, then the delimiting grid is [0, 1, 2, 3, 4, 5].
        self._voxel_grid = [np.linspace(0, self._volume_limits[i], self._number_of_voxels[i] + 1) for i in range(3)]

        # All access to voxel_positions will be done directly through the inner
        # class _VoxelPositions, so no need for a private property here
        self.voxel_positions = self._VoxelPositions(self._volume_limits, self._number_of_voxels)
        self._voxel_data = np.zeros(self._number_of_voxels, dtype = int)


    @property
    def voxel_sizes(self):
        return self._voxel_sizes


    @property
    def voxel_grid(self):
        return self._voxel_grid


    @property
    def voxel_data(self):
        return self._voxel_data


    def traverse_python(self, lor_indices = None):
        # Adapted from &#34;A Fast Voxel Traversal Algorithm for Ray Tracing&#34; by
        # John Amanatides and Andrew Woo.

        # Traverse voxels for all LoRs by default
        if lor_indices is None:
            lor_indices = range(self._number_of_lines)

        if not hasattr(lor_indices, &#34;__iter__&#34;):
            raise TypeError(&#34;[ERROR]: The `lor_indices` parameter must be iterable.&#34;)

        # The adapted grid traversal algorithm
        for li in lor_indices:
            # Define a line as L(t) = U + t V
            # If an LoR is defined as two points P1 and P2, then
            # U = P1 and V = P2 - P1
            p1 = self._line_data[li, 1:4]
            p2 = self._line_data[li, 4:7]
            u = p1
            v = p2 - p1

            ##############################################################
            # Initialisation stage

            # The step [sx, sy, sz] defines the sense of the LoR.
            # If V[0] is positive, then sx = 1
            # If V[0] is negative, then sx = -1
            step = np.array([1, 1, 1], dtype = int)
            for i, c in enumerate(v):
                if c &lt; 0:
                    step[i] = -1

            # The current voxel indices [ix, iy, iz] that the line passes
            # through.
            voxel_index = np.array([0, 0, 0], dtype = int)

            # The value of t at which the line passes through to the next
            # voxel, for each dimension.
            t_next = np.array([0., 0., 0.], dtype = float)

            # Find the initial voxel that the line starts from, for each
            # dimension.
            for i in range(len(voxel_index)):
                # If, for dimension x, there are 5 voxels between coordinates 0
                # and 5, then the delimiting grid is [0, 1, 2, 3, 4, 5].
                # If the line starts at 1.5, then it is part of the voxel at
                # index 1.
                voxel_index[i] = np.searchsorted(self._voxel_grid[i], u[i], side = &#34;right&#34;) - 1

                # If the line is going &#34;up&#34;, the next voxel is the next one
                if v[i] &gt;= 0:
                    offset = 1
                # If the line is going &#34;down&#34;, the next voxel is the current one
                else:
                    offset = 0
                t_next[i] = (self._voxel_grid[i][voxel_index[i] + offset] - u[i]) / v[i]

            # delta_t indicates how far along the ray we must move (in units of
            # t) for each component to be equal to the size of the voxel in
            # that dimension.
            delta_t = np.abs(self._voxel_sizes / v)

            ###############################################################
            # Incremental traversal stage

            # Loop until we reach the last voxel in space
            while (voxel_index &lt; self._number_of_voxels).all() and (voxel_index &gt;= 0).all():

                self._voxel_data[tuple(voxel_index)] += 1

                # If p2 is fully bounded by the voxel, stop the algorithm
                if ((self.voxel_positions._at_corner(voxel_index) &lt; p2).all() and
                    (self.voxel_positions._at_corner(voxel_index + 1) &gt; p2).all()):
                    break

                # The dimension of the minimum t that makes the line pass
                # through to the next voxel
                min_i = t_next.argmin()
                t_next[min_i] += delta_t[min_i]
                voxel_index[min_i] += step[min_i]


    def traverse(self, lor_indices = None):
        # Traverse all intersecting voxels for selected LoRs.

        # Traverse voxels for all LoRs by default
        if lor_indices is None:
            lor_indices = range(self._number_of_lines)

        if not hasattr(lor_indices, &#34;__iter__&#34;):
            raise TypeError(&#34;[ERROR]: The `lor_indices` parameter must be iterable.&#34;)

        traverse3d(
            self._voxel_data,
            self._line_data[lor_indices],
            self._voxel_grid[0],
            self._voxel_grid[1],
            self._voxel_grid[2]
        )


    def indices(self, coords):
        # Find the voxel indices for a point at `coords`
        coords = np.asarray(coords, dtype = float)
        if coords.ndim != 1 or coords.shape[0] != 3:
            raise ValueError(&#34;The `coords` parameter must have shape (3,). Received {}.&#34;.format(coords))

        indices = np.array([0, 0, 0], dtype = int)
        for i in range(3):
            indices[i] = np.searchsorted(self._voxel_grid[i], coords[i], side = &#34;right&#34;) - 1

        return indices


    def cube_trace(self, index, opacity = 0.4, color = None, colorscale = False):
        # For a small number of cubes

        index = np.asarray(index, dtype = int)
        xyz = self.voxel_positions.at_corner(*index)

        x = np.array([0, 0, 1, 1, 0, 0, 1, 1]) * self._voxel_sizes[0]
        y = np.array([0, 1, 1, 0, 0, 1, 1, 0]) * self._voxel_sizes[1]
        z = np.array([0, 0, 0, 0, 1, 1, 1, 1]) * self._voxel_sizes[2]
        i = np.array([7, 0, 0, 0, 4, 4, 6, 6, 4, 0, 3, 2])
        j = np.array([3, 4, 1, 2, 5, 6, 5, 2, 0, 1, 6, 3])
        k = np.array([0, 7, 2, 3, 6, 7, 1, 1, 5, 5, 7, 6])

        cube = dict(
            x =  x + xyz[0],
            y =  y + xyz[1],
            z =  z + xyz[2],
            i =  i,
            j =  j,
            k =  k,
            opacity = opacity,
            color = color
        )

        if colorscale:
            cmap = matplotlib.cm.get_cmap(&#34;magma&#34;)
            c = cmap(self._voxel_data[tuple(index)] / (self._voxel_data.max() or 1))
            cube.update(
                color = &#34;rgb({},{},{})&#34;.format(c[0], c[1], c[2])
            )

        return go.Mesh3d(cube)


    def cubes_traces(
        self,
        condition = lambda voxel_data: voxel_data &gt; 0,
        opacity = 0.4,
        color = None,
        colorscale = False
    ):
        # For a small number of cubes

        indices = np.argwhere(condition(self._voxel_data))
        traces = [self.cube_trace(i, opacity = opacity, color = color, colorscale = colorscale) for i in indices]

        return traces


    def voxels_trace(
        self,
        condition = lambda voxel_data: voxel_data &gt; 0,
        size = 4,
        opacity = 0.4,
        color = None,
        colorscale = False
    ):
        # For a large number of cubes

        filtered_indices = np.argwhere(condition(self._voxel_data))
        positions = self.voxel_positions._at(filtered_indices)

        marker = dict(
            size = size,
            color = color,
            symbol = &#34;square&#34;
        )

        if colorscale:
            cvalues = [self._voxel_data[tuple(t)] for t in filtered_indices]
            marker.update(colorscale = &#34;Magma&#34;, color = cvalues)

        voxels = dict(
            x = positions[:, 0],
            y = positions[:, 1],
            z = positions[:, 2],
            opacity = opacity,
            mode = &#34;markers&#34;,
            marker = marker
        )

        return go.Scatter3d(voxels)


    def heatmap_trace(
        self,
        ix = None,
        iy = None,
        iz = None,
        width = 0
    ):

        if ix is not None:
            x = self._voxel_grid[1]
            y = self._voxel_grid[2]
            z = self._voxel_data[ix, :, :]

            for i in range(1, width + 1):
                z = z + self._voxel_data[ix + i, :, :]
                z = z + self._voxel_data[ix - i, :, :]

        elif iy is not None:
            x = self._voxel_grid[0]
            y = self._voxel_grid[2]
            z = self._voxel_data[:, iy, :]

            for i in range(1, width + 1):
                z = z + self._voxel_data[:, iy + i, :]
                z = z + self._voxel_data[:, iy - i, :]

        elif iz is not None:
            x = self._voxel_grid[0]
            y = self._voxel_grid[1]
            z = self._voxel_data[:, :, iz]

            for i in range(1, width + 1):
                z = z + self._voxel_data[:, :, iz + i]
                z = z + self._voxel_data[:, :, iz - i]

        else:
            raise ValueError(&#34;[ERROR]: One of the `ix`, `iy`, `iz` slice indices must be provided.&#34;)

        heatmap = dict(
            x = x,
            y = y,
            z = z,
            colorscale = &#34;Magma&#34;,
            transpose = True
        )

        return go.Heatmap(heatmap)


    def __str__(self):
        # Shown when calling print(class)
        docstr = &#34;&#34;

        docstr += &#34;number_of_lines =   {}\n\n&#34;.format(self.number_of_lines)
        docstr += &#34;volume_limits =     {}\n&#34;.format(self.volume_limits)
        docstr += &#34;number_of_voxels =  {}\n&#34;.format(self.number_of_voxels)
        docstr += &#34;voxel_sizes =       {}\n\n&#34;.format(self.voxel_sizes)

        docstr += &#34;line_data = \n&#34;
        docstr += self._line_data.__str__()

        docstr += &#34;\n\nvoxel_data = \n&#34;
        docstr += self._voxel_data.__str__()

        return docstr


    def __repr__(self):
        # Shown when writing the class on a REPR

        docstr = &#34;Class instance that inherits from `pept.VoxelData`.\n\n&#34; + self.__str__() + &#34;\n\n&#34;

        return docstr</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pept.VoxelData.line_data"><code class="name">var <span class="ident">line_data</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def line_data(self):
    return self._line_data</code></pre>
</details>
</dd>
<dt id="pept.VoxelData.number_of_lines"><code class="name">var <span class="ident">number_of_lines</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def number_of_lines(self):
    return self._number_of_lines</code></pre>
</details>
</dd>
<dt id="pept.VoxelData.number_of_voxels"><code class="name">var <span class="ident">number_of_voxels</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def number_of_voxels(self):
    return self._number_of_voxels</code></pre>
</details>
</dd>
<dt id="pept.VoxelData.volume_limits"><code class="name">var <span class="ident">volume_limits</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def volume_limits(self):
    return self._volume_limits</code></pre>
</details>
</dd>
<dt id="pept.VoxelData.voxel_data"><code class="name">var <span class="ident">voxel_data</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def voxel_data(self):
    return self._voxel_data</code></pre>
</details>
</dd>
<dt id="pept.VoxelData.voxel_grid"><code class="name">var <span class="ident">voxel_grid</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def voxel_grid(self):
    return self._voxel_grid</code></pre>
</details>
</dd>
<dt id="pept.VoxelData.voxel_sizes"><code class="name">var <span class="ident">voxel_sizes</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def voxel_sizes(self):
    return self._voxel_sizes</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pept.VoxelData.cube_trace"><code class="name flex">
<span>def <span class="ident">cube_trace</span></span>(<span>self, index, opacity=0.4, color=None, colorscale=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def cube_trace(self, index, opacity = 0.4, color = None, colorscale = False):
    # For a small number of cubes

    index = np.asarray(index, dtype = int)
    xyz = self.voxel_positions.at_corner(*index)

    x = np.array([0, 0, 1, 1, 0, 0, 1, 1]) * self._voxel_sizes[0]
    y = np.array([0, 1, 1, 0, 0, 1, 1, 0]) * self._voxel_sizes[1]
    z = np.array([0, 0, 0, 0, 1, 1, 1, 1]) * self._voxel_sizes[2]
    i = np.array([7, 0, 0, 0, 4, 4, 6, 6, 4, 0, 3, 2])
    j = np.array([3, 4, 1, 2, 5, 6, 5, 2, 0, 1, 6, 3])
    k = np.array([0, 7, 2, 3, 6, 7, 1, 1, 5, 5, 7, 6])

    cube = dict(
        x =  x + xyz[0],
        y =  y + xyz[1],
        z =  z + xyz[2],
        i =  i,
        j =  j,
        k =  k,
        opacity = opacity,
        color = color
    )

    if colorscale:
        cmap = matplotlib.cm.get_cmap(&#34;magma&#34;)
        c = cmap(self._voxel_data[tuple(index)] / (self._voxel_data.max() or 1))
        cube.update(
            color = &#34;rgb({},{},{})&#34;.format(c[0], c[1], c[2])
        )

    return go.Mesh3d(cube)</code></pre>
</details>
</dd>
<dt id="pept.VoxelData.cubes_traces"><code class="name flex">
<span>def <span class="ident">cubes_traces</span></span>(<span>self, condition=<function VoxelData.<lambda> at 0x11815e560>, opacity=0.4, color=None, colorscale=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def cubes_traces(
    self,
    condition = lambda voxel_data: voxel_data &gt; 0,
    opacity = 0.4,
    color = None,
    colorscale = False
):
    # For a small number of cubes

    indices = np.argwhere(condition(self._voxel_data))
    traces = [self.cube_trace(i, opacity = opacity, color = color, colorscale = colorscale) for i in indices]

    return traces</code></pre>
</details>
</dd>
<dt id="pept.VoxelData.heatmap_trace"><code class="name flex">
<span>def <span class="ident">heatmap_trace</span></span>(<span>self, ix=None, iy=None, iz=None, width=0)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def heatmap_trace(
    self,
    ix = None,
    iy = None,
    iz = None,
    width = 0
):

    if ix is not None:
        x = self._voxel_grid[1]
        y = self._voxel_grid[2]
        z = self._voxel_data[ix, :, :]

        for i in range(1, width + 1):
            z = z + self._voxel_data[ix + i, :, :]
            z = z + self._voxel_data[ix - i, :, :]

    elif iy is not None:
        x = self._voxel_grid[0]
        y = self._voxel_grid[2]
        z = self._voxel_data[:, iy, :]

        for i in range(1, width + 1):
            z = z + self._voxel_data[:, iy + i, :]
            z = z + self._voxel_data[:, iy - i, :]

    elif iz is not None:
        x = self._voxel_grid[0]
        y = self._voxel_grid[1]
        z = self._voxel_data[:, :, iz]

        for i in range(1, width + 1):
            z = z + self._voxel_data[:, :, iz + i]
            z = z + self._voxel_data[:, :, iz - i]

    else:
        raise ValueError(&#34;[ERROR]: One of the `ix`, `iy`, `iz` slice indices must be provided.&#34;)

    heatmap = dict(
        x = x,
        y = y,
        z = z,
        colorscale = &#34;Magma&#34;,
        transpose = True
    )

    return go.Heatmap(heatmap)</code></pre>
</details>
</dd>
<dt id="pept.VoxelData.indices"><code class="name flex">
<span>def <span class="ident">indices</span></span>(<span>self, coords)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def indices(self, coords):
    # Find the voxel indices for a point at `coords`
    coords = np.asarray(coords, dtype = float)
    if coords.ndim != 1 or coords.shape[0] != 3:
        raise ValueError(&#34;The `coords` parameter must have shape (3,). Received {}.&#34;.format(coords))

    indices = np.array([0, 0, 0], dtype = int)
    for i in range(3):
        indices[i] = np.searchsorted(self._voxel_grid[i], coords[i], side = &#34;right&#34;) - 1

    return indices</code></pre>
</details>
</dd>
<dt id="pept.VoxelData.traverse"><code class="name flex">
<span>def <span class="ident">traverse</span></span>(<span>self, lor_indices=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def traverse(self, lor_indices = None):
    # Traverse all intersecting voxels for selected LoRs.

    # Traverse voxels for all LoRs by default
    if lor_indices is None:
        lor_indices = range(self._number_of_lines)

    if not hasattr(lor_indices, &#34;__iter__&#34;):
        raise TypeError(&#34;[ERROR]: The `lor_indices` parameter must be iterable.&#34;)

    traverse3d(
        self._voxel_data,
        self._line_data[lor_indices],
        self._voxel_grid[0],
        self._voxel_grid[1],
        self._voxel_grid[2]
    )</code></pre>
</details>
</dd>
<dt id="pept.VoxelData.traverse_python"><code class="name flex">
<span>def <span class="ident">traverse_python</span></span>(<span>self, lor_indices=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def traverse_python(self, lor_indices = None):
    # Adapted from &#34;A Fast Voxel Traversal Algorithm for Ray Tracing&#34; by
    # John Amanatides and Andrew Woo.

    # Traverse voxels for all LoRs by default
    if lor_indices is None:
        lor_indices = range(self._number_of_lines)

    if not hasattr(lor_indices, &#34;__iter__&#34;):
        raise TypeError(&#34;[ERROR]: The `lor_indices` parameter must be iterable.&#34;)

    # The adapted grid traversal algorithm
    for li in lor_indices:
        # Define a line as L(t) = U + t V
        # If an LoR is defined as two points P1 and P2, then
        # U = P1 and V = P2 - P1
        p1 = self._line_data[li, 1:4]
        p2 = self._line_data[li, 4:7]
        u = p1
        v = p2 - p1

        ##############################################################
        # Initialisation stage

        # The step [sx, sy, sz] defines the sense of the LoR.
        # If V[0] is positive, then sx = 1
        # If V[0] is negative, then sx = -1
        step = np.array([1, 1, 1], dtype = int)
        for i, c in enumerate(v):
            if c &lt; 0:
                step[i] = -1

        # The current voxel indices [ix, iy, iz] that the line passes
        # through.
        voxel_index = np.array([0, 0, 0], dtype = int)

        # The value of t at which the line passes through to the next
        # voxel, for each dimension.
        t_next = np.array([0., 0., 0.], dtype = float)

        # Find the initial voxel that the line starts from, for each
        # dimension.
        for i in range(len(voxel_index)):
            # If, for dimension x, there are 5 voxels between coordinates 0
            # and 5, then the delimiting grid is [0, 1, 2, 3, 4, 5].
            # If the line starts at 1.5, then it is part of the voxel at
            # index 1.
            voxel_index[i] = np.searchsorted(self._voxel_grid[i], u[i], side = &#34;right&#34;) - 1

            # If the line is going &#34;up&#34;, the next voxel is the next one
            if v[i] &gt;= 0:
                offset = 1
            # If the line is going &#34;down&#34;, the next voxel is the current one
            else:
                offset = 0
            t_next[i] = (self._voxel_grid[i][voxel_index[i] + offset] - u[i]) / v[i]

        # delta_t indicates how far along the ray we must move (in units of
        # t) for each component to be equal to the size of the voxel in
        # that dimension.
        delta_t = np.abs(self._voxel_sizes / v)

        ###############################################################
        # Incremental traversal stage

        # Loop until we reach the last voxel in space
        while (voxel_index &lt; self._number_of_voxels).all() and (voxel_index &gt;= 0).all():

            self._voxel_data[tuple(voxel_index)] += 1

            # If p2 is fully bounded by the voxel, stop the algorithm
            if ((self.voxel_positions._at_corner(voxel_index) &lt; p2).all() and
                (self.voxel_positions._at_corner(voxel_index + 1) &gt; p2).all()):
                break

            # The dimension of the minimum t that makes the line pass
            # through to the next voxel
            min_i = t_next.argmin()
            t_next[min_i] += delta_t[min_i]
            voxel_index[min_i] += step[min_i]</code></pre>
</details>
</dd>
<dt id="pept.VoxelData.voxels_trace"><code class="name flex">
<span>def <span class="ident">voxels_trace</span></span>(<span>self, condition=<function VoxelData.<lambda> at 0x11815e680>, size=4, opacity=0.4, color=None, colorscale=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def voxels_trace(
    self,
    condition = lambda voxel_data: voxel_data &gt; 0,
    size = 4,
    opacity = 0.4,
    color = None,
    colorscale = False
):
    # For a large number of cubes

    filtered_indices = np.argwhere(condition(self._voxel_data))
    positions = self.voxel_positions._at(filtered_indices)

    marker = dict(
        size = size,
        color = color,
        symbol = &#34;square&#34;
    )

    if colorscale:
        cvalues = [self._voxel_data[tuple(t)] for t in filtered_indices]
        marker.update(colorscale = &#34;Magma&#34;, color = cvalues)

    voxels = dict(
        x = positions[:, 0],
        y = positions[:, 1],
        z = positions[:, 2],
        opacity = opacity,
        mode = &#34;markers&#34;,
        marker = marker
    )

    return go.Scatter3d(voxels)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#pept">PEPT</a><ul>
<li><a href="#positron-emission-particle-tracking">Positron Emission Particle Tracking</a></li>
<li><a href="#getting-started">Getting Started</a><ul>
<li><a href="#prerequisites">Prerequisites</a></li>
<li><a href="#installation">Installation</a></li>
<li><a href="#example-usage">Example usage</a></li>
</ul>
</li>
<li><a href="#performance">Performance</a></li>
<li><a href="#help-and-support">Help and Support</a></li>
<li><a href="#contributing">Contributing</a></li>
<li><a href="#citing">Citing</a></li>
<li><a href="#licensing">Licensing</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="pept.base" href="base/index.html">pept.base</a></code></li>
<li><code><a title="pept.diagnostics" href="diagnostics/index.html">pept.diagnostics</a></code></li>
<li><code><a title="pept.scanners" href="scanners/index.html">pept.scanners</a></code></li>
<li><code><a title="pept.simulation" href="simulation/index.html">pept.simulation</a></code></li>
<li><code><a title="pept.tests" href="tests/index.html">pept.tests</a></code></li>
<li><code><a title="pept.tracking" href="tracking/index.html">pept.tracking</a></code></li>
<li><code><a title="pept.utilities" href="utilities/index.html">pept.utilities</a></code></li>
<li><code><a title="pept.visualisation" href="visualisation/index.html">pept.visualisation</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pept.LineData" href="#pept.LineData">LineData</a></code></h4>
<ul class="">
<li><code><a title="pept.LineData.line_data" href="#pept.LineData.line_data">line_data</a></code></li>
<li><code><a title="pept.LineData.lines_trace" href="#pept.LineData.lines_trace">lines_trace</a></code></li>
<li><code><a title="pept.LineData.number_of_lines" href="#pept.LineData.number_of_lines">number_of_lines</a></code></li>
<li><code><a title="pept.LineData.number_of_samples" href="#pept.LineData.number_of_samples">number_of_samples</a></code></li>
<li><code><a title="pept.LineData.overlap" href="#pept.LineData.overlap">overlap</a></code></li>
<li><code><a title="pept.LineData.plot_all_lines" href="#pept.LineData.plot_all_lines">plot_all_lines</a></code></li>
<li><code><a title="pept.LineData.plot_all_lines_alt_axes" href="#pept.LineData.plot_all_lines_alt_axes">plot_all_lines_alt_axes</a></code></li>
<li><code><a title="pept.LineData.plot_lines_sample_n" href="#pept.LineData.plot_lines_sample_n">plot_lines_sample_n</a></code></li>
<li><code><a title="pept.LineData.plot_lines_sample_n_alt_axes" href="#pept.LineData.plot_lines_sample_n_alt_axes">plot_lines_sample_n_alt_axes</a></code></li>
<li><code><a title="pept.LineData.sample_n" href="#pept.LineData.sample_n">sample_n</a></code></li>
<li><code><a title="pept.LineData.sample_size" href="#pept.LineData.sample_size">sample_size</a></code></li>
<li><code><a title="pept.LineData.to_csv" href="#pept.LineData.to_csv">to_csv</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pept.PointData" href="#pept.PointData">PointData</a></code></h4>
<ul class="">
<li><code><a title="pept.PointData.all_points_trace" href="#pept.PointData.all_points_trace">all_points_trace</a></code></li>
<li><code><a title="pept.PointData.all_points_trace_colorbar" href="#pept.PointData.all_points_trace_colorbar">all_points_trace_colorbar</a></code></li>
<li><code><a title="pept.PointData.number_of_points" href="#pept.PointData.number_of_points">number_of_points</a></code></li>
<li><code><a title="pept.PointData.number_of_samples" href="#pept.PointData.number_of_samples">number_of_samples</a></code></li>
<li><code><a title="pept.PointData.overlap" href="#pept.PointData.overlap">overlap</a></code></li>
<li><code><a title="pept.PointData.plot_all_points" href="#pept.PointData.plot_all_points">plot_all_points</a></code></li>
<li><code><a title="pept.PointData.plot_all_points_alt_axes" href="#pept.PointData.plot_all_points_alt_axes">plot_all_points_alt_axes</a></code></li>
<li><code><a title="pept.PointData.plot_points_sample_n" href="#pept.PointData.plot_points_sample_n">plot_points_sample_n</a></code></li>
<li><code><a title="pept.PointData.plot_points_sample_n_alt_axes" href="#pept.PointData.plot_points_sample_n_alt_axes">plot_points_sample_n_alt_axes</a></code></li>
<li><code><a title="pept.PointData.point_data" href="#pept.PointData.point_data">point_data</a></code></li>
<li><code><a title="pept.PointData.points_sample_n_trace" href="#pept.PointData.points_sample_n_trace">points_sample_n_trace</a></code></li>
<li><code><a title="pept.PointData.points_sample_n_trace_colorbar" href="#pept.PointData.points_sample_n_trace_colorbar">points_sample_n_trace_colorbar</a></code></li>
<li><code><a title="pept.PointData.points_trace" href="#pept.PointData.points_trace">points_trace</a></code></li>
<li><code><a title="pept.PointData.sample_n" href="#pept.PointData.sample_n">sample_n</a></code></li>
<li><code><a title="pept.PointData.sample_size" href="#pept.PointData.sample_size">sample_size</a></code></li>
<li><code><a title="pept.PointData.to_csv" href="#pept.PointData.to_csv">to_csv</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pept.VoxelData" href="#pept.VoxelData">VoxelData</a></code></h4>
<ul class="two-column">
<li><code><a title="pept.VoxelData.cube_trace" href="#pept.VoxelData.cube_trace">cube_trace</a></code></li>
<li><code><a title="pept.VoxelData.cubes_traces" href="#pept.VoxelData.cubes_traces">cubes_traces</a></code></li>
<li><code><a title="pept.VoxelData.heatmap_trace" href="#pept.VoxelData.heatmap_trace">heatmap_trace</a></code></li>
<li><code><a title="pept.VoxelData.indices" href="#pept.VoxelData.indices">indices</a></code></li>
<li><code><a title="pept.VoxelData.line_data" href="#pept.VoxelData.line_data">line_data</a></code></li>
<li><code><a title="pept.VoxelData.number_of_lines" href="#pept.VoxelData.number_of_lines">number_of_lines</a></code></li>
<li><code><a title="pept.VoxelData.number_of_voxels" href="#pept.VoxelData.number_of_voxels">number_of_voxels</a></code></li>
<li><code><a title="pept.VoxelData.traverse" href="#pept.VoxelData.traverse">traverse</a></code></li>
<li><code><a title="pept.VoxelData.traverse_python" href="#pept.VoxelData.traverse_python">traverse_python</a></code></li>
<li><code><a title="pept.VoxelData.volume_limits" href="#pept.VoxelData.volume_limits">volume_limits</a></code></li>
<li><code><a title="pept.VoxelData.voxel_data" href="#pept.VoxelData.voxel_data">voxel_data</a></code></li>
<li><code><a title="pept.VoxelData.voxel_grid" href="#pept.VoxelData.voxel_grid">voxel_grid</a></code></li>
<li><code><a title="pept.VoxelData.voxel_sizes" href="#pept.VoxelData.voxel_sizes">voxel_sizes</a></code></li>
<li><code><a title="pept.VoxelData.voxels_trace" href="#pept.VoxelData.voxels_trace">voxels_trace</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>