<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.3" />
<title>pept.visualisation API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pept.visualisation</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-


# File   : __init__.py
# License: License: GNU v3.0
# Author : Andrei Leonard Nicusan &lt;a.l.nicusan@bham.ac.uk&gt;
# Date   : 22.08.2019


from    .plotly_grapher     import  PlotlyGrapher

__all__ = [
    &#34;PlotlyGrapher&#34;
]


__author__ =        &#34;Andrei Leonard Nicusan&#34;
__credits__ =       [&#34;Andrei Leonard Nicusan&#34;, &#34;Kit Windows-Yule&#34;, &#34;Sam Manger&#34;]
__license__ =       &#34;GNU v3.0&#34;
__version__ =       &#34;0.1&#34;
__maintainer__ =    &#34;Andrei Leonard Nicusan&#34;
__email__ =         &#34;a.l.nicusan@bham.ac.uk&#34;
__status__ =        &#34;Development&#34;</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="pept.visualisation.plotly_grapher" href="plotly_grapher.html">pept.visualisation.plotly_grapher</a></code></dt>
<dd>
<section class="desc"><p>The <em>plotly_grapher</em> module implements Plotly-based visualisation tools
to aid PEPT data analysis and to create publication-ready figures â€¦</p></section>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pept.visualisation.PlotlyGrapher"><code class="flex name class">
<span>class <span class="ident">PlotlyGrapher</span></span>
<span>(</span><span>rows=1, cols=1, xlim=[0, 500], ylim=[0, 500], zlim=[0, 712], subplot_titles=['
'])</span>
</code></dt>
<dd>
<section class="desc"><p>A class for PEPT data visualisation using Plotly-based 3D plots.</p>
<p>The <em>PlotlyGrapher</em> class can create and automatically configure 3D subplots
for PEPT data visualisation. It can create and handle any number of subplots,
automatically configuring them to the ''alternative PEPT 3D axes convention''.
The PEPT 3D axes convention has the <em>y</em>-axis
pointing upwards, such that the vertical screens of a PEPT scanner represent
the <em>xy</em>-plane. The class provides functionality for plotting 3D scatter or
line plots, with optional colorbars.</p>
<p>The class provides easy access to the most common configuration parameters for
the plots, such as axes limits, subplot titles, colorbar titles, etc. It can
work with pre-computed Plotly traces (such as the ones from the <a title="pept" href="../index.html"><code>pept</code></a> base
classes), as well as with numpy arrays.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rows</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The number of rows of subplots. The default is 1.</dd>
<dt><strong><code>cols</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The number of columns of subplots. The default is 1.</dd>
<dt><strong><code>xlim</code></strong> :&ensp;<code>list</code> or <code>numpy.ndarray</code>, optional</dt>
<dd>A list of length 2, formatted as <code>[x_min, x_max]</code>, where <code>x_min</code> is
the lower limit of the x-axis of all the subplots and <code>x_max</code> is the
upper limit of the x-axis of all the subplots. The default is
[0, 500], as for the Birmingham PEPT.</dd>
<dt><strong><code>ylim</code></strong> :&ensp;<code>list</code> or <code>numpy.ndarray</code>, optional</dt>
<dd>A list of length 2, formatted as <code>[y_min, y_max]</code>, where <code>y_min</code> is
the lower limit of the y-axis of all the subplots and <code>y_max</code> is the
upper limit of the y-axis of all the subplots. The default is
[0, 500], as for the Birmingham PEPT.</dd>
<dt><strong><code>zlim</code></strong> :&ensp;<code>list</code> or <code>numpy.ndarray</code>, optional</dt>
<dd>A list of length 2, formatted as <code>[z_min, z_max]</code>, where <code>z_min</code> is
the lower limit of the z-axis of all the subplots and <code>z_max</code> is the
upper limit of the z-axis of all the subplots. The default is
[0, 712], a usual screen separation for the Birmingham PEPT.</dd>
<dt><strong><code>subplot_titles</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>A list of the titles of the subplots. The default is a list of empty
strings.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>xlim</code></strong> :&ensp;<code>list</code> or <code>numpy.ndarray</code></dt>
<dd>A list of length 2, formatted as <code>[x_min, x_max]</code>, where <code>x_min</code> is
the lower limit of the x-axis of all the subplots and <code>x_max</code> is the
upper limit of the x-axis of all the subplots.</dd>
<dt><strong><code>ylim</code></strong> :&ensp;<code>list</code> or <code>numpy.ndarray</code></dt>
<dd>A list of length 2, formatted as <code>[y_min, y_max]</code>, where <code>y_min</code> is
the lower limit of the y-axis of all the subplots and <code>y_max</code> is the
upper limit of the y-axis of all the subplots.</dd>
<dt><strong><code>zlim</code></strong> :&ensp;<code>list</code> or <code>numpy.ndarray</code></dt>
<dd>A list of length 2, formatted as <code>[z_min, z_max]</code>, where <code>z_min</code> is
the lower limit of the z-axis of all the subplots and <code>z_max</code> is the
upper limit of the z-axis of all the subplots.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>Plotly</code> <code>Figure</code> <code>instance</code></dt>
<dd>A Plotly Figure instance, with any number of subplots (as defined by
<code>rows</code> and <code>cols</code>) pre-configured for PEPT data. It is created when
calling <code>create_figure</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If <code>rows</code> &lt; 1 or <code>cols</code> &lt; 1</dd>
<dt><code>TypeError</code></dt>
<dd>If <code>xlim</code>, <code>ylim</code> or <code>zlim</code> are not lists of length 2.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The class constructor (calling PlotlyGrapher()) is separate from the figure
creation, so that one can have instances of both the <a title="pept.visualisation.PlotlyGrapher" href="#pept.visualisation.PlotlyGrapher"><code>PlotlyGrapher</code></a> and the
Plotly figure it creates. An example call would be:</p>
<pre><code>&gt;&gt;&gt; grapher = PlotlyGrapher()
&gt;&gt;&gt; fig = grapher.create_figure()
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class PlotlyGrapher:
    &#39;&#39;&#39;A class for PEPT data visualisation using Plotly-based 3D plots.

    The *PlotlyGrapher* class can create and automatically configure 3D subplots
    for PEPT data visualisation. It can create and handle any number of subplots,
    automatically configuring them to the &#39;&#39;alternative PEPT 3D axes convention&#39;&#39;.
    The PEPT 3D axes convention has the *y*-axis
    pointing upwards, such that the vertical screens of a PEPT scanner represent
    the *xy*-plane. The class provides functionality for plotting 3D scatter or
    line plots, with optional colorbars.

    The class provides easy access to the most common configuration parameters for
    the plots, such as axes limits, subplot titles, colorbar titles, etc. It can
    work with pre-computed Plotly traces (such as the ones from the `pept` base
    classes), as well as with numpy arrays.

    Parameters
    ----------
    rows : int, optional
        The number of rows of subplots. The default is 1.
    cols : int, optional
        The number of columns of subplots. The default is 1.
    xlim : list or numpy.ndarray, optional
        A list of length 2, formatted as `[x_min, x_max]`, where `x_min` is
        the lower limit of the x-axis of all the subplots and `x_max` is the
        upper limit of the x-axis of all the subplots. The default is
        [0, 500], as for the Birmingham PEPT.
    ylim : list or numpy.ndarray, optional
        A list of length 2, formatted as `[y_min, y_max]`, where `y_min` is
        the lower limit of the y-axis of all the subplots and `y_max` is the
        upper limit of the y-axis of all the subplots. The default is
        [0, 500], as for the Birmingham PEPT.
    zlim : list or numpy.ndarray, optional
        A list of length 2, formatted as `[z_min, z_max]`, where `z_min` is
        the lower limit of the z-axis of all the subplots and `z_max` is the
        upper limit of the z-axis of all the subplots. The default is
        [0, 712], a usual screen separation for the Birmingham PEPT.
    subplot_titles : list of str, optional
        A list of the titles of the subplots. The default is a list of empty
        strings.

    Attributes
    ----------
    xlim : list or numpy.ndarray
        A list of length 2, formatted as `[x_min, x_max]`, where `x_min` is
        the lower limit of the x-axis of all the subplots and `x_max` is the
        upper limit of the x-axis of all the subplots.
    ylim : list or numpy.ndarray
        A list of length 2, formatted as `[y_min, y_max]`, where `y_min` is
        the lower limit of the y-axis of all the subplots and `y_max` is the
        upper limit of the y-axis of all the subplots.
    zlim : list or numpy.ndarray
        A list of length 2, formatted as `[z_min, z_max]`, where `z_min` is
        the lower limit of the z-axis of all the subplots and `z_max` is the
        upper limit of the z-axis of all the subplots.
    fig : Plotly Figure instance
        A Plotly Figure instance, with any number of subplots (as defined by
        `rows` and `cols`) pre-configured for PEPT data. It is created when
        calling `create_figure`.

    Raises
    ------
    ValueError
        If `rows` &lt; 1 or `cols` &lt; 1
    TypeError
        If `xlim`, `ylim` or `zlim` are not lists of length 2.

    Notes
    -----
    The class constructor (calling PlotlyGrapher()) is separate from the figure
    creation, so that one can have instances of both the `PlotlyGrapher` and the
    Plotly figure it creates. An example call would be:

    &gt;&gt;&gt; grapher = PlotlyGrapher()
    &gt;&gt;&gt; fig = grapher.create_figure()

    &#39;&#39;&#39;

    def __init__(self,
                 rows = 1, cols = 1,
                 xlim = [0, 500], ylim = [0, 500], zlim = [0, 712],
                 subplot_titles = [&#39;  &#39;]):

        if rows &lt; 1 or cols &lt; 1:
            raise ValueError(&#34;\n[ERROR]: The number of rows and cols have to be larger than 1\n&#34;)

        self._rows = rows
        self._cols = cols

        if len(xlim) != 2 or len(ylim) != 2 or len(zlim) != 2:
            raise TypeError(&#34;\n[ERROR]: xlim, ylim and zlim need to be lists of length 2, formatted as xlim = [x_min, x_max] etc.\n&#34;)

        self._xlim = xlim
        self._ylim = ylim
        self._zlim = zlim

        self._subplot_titles = subplot_titles
        self._subplot_titles.extend([&#39;  &#39;] * (rows * cols - len(subplot_titles)))

        self._fig = None


    def create_figure(self):
        &#39;&#39;&#39;Create a Plotly figure, pre-configured for PEPT data.

        This function creates a Plotly figure with any number of subplots,
        as given in the class instantiation call. It pre-configures them to have
        the *y*-axis pointing upwards, as per the PEPT 3D axes convention. It
        also sets the axes limits and labels.

        Returns
        -------
        fig : Plotly Figure instance
            A Plotly Figure instance, with any number of subplots (as defined when instantiating
            the class) pre-configured for PEPT data.

        &#39;&#39;&#39;

        specs = [[{&#34;type&#34;: &#34;scatter3d&#34;}] * self._cols] * self._rows

        self._fig = make_subplots(rows = self._rows, cols = self._cols,
                    specs = specs, subplot_titles = self._subplot_titles,
                    horizontal_spacing = 0.005, vertical_spacing = 0.05)

        self._fig[&#39;layout&#39;].update(margin = dict(l=0,r=0,b=30,t=30), showlegend = False)

        # For every subplot (scene), set axes&#39; ratios and limits
        # Also set the y axis to point upwards
        # Plotly naming convention of scenes: &#39;scene&#39;, &#39;scene2&#39;, etc.
        for i in range(self._rows):
            for j in range(self._cols):
                if i == j == 0:
                    scene = &#39;scene&#39;
                else:
                    scene = &#39;scene{}&#39;.format(i * self._cols + j + 1)

                # Justify subplot title on the left
                self._fig.layout.annotations[i * self._cols + j].update(x = (j + 0.15) / self._cols)
                self._fig[&#39;layout&#39;][scene].update(aspectmode = &#39;manual&#39;,
                                                 aspectratio = {&#39;x&#39;: 1, &#39;y&#39;: 1, &#39;z&#39;: 1},
                                                 camera = {&#39;up&#39;: {&#39;x&#39;: 0, &#39;y&#39;: 1, &#39;z&#39;:0},
                                                           &#39;eye&#39;: {&#39;x&#39;: 1, &#39;y&#39;: 1, &#39;z&#39;: 1}},
                                                 xaxis = {&#39;range&#39;: self._xlim,
                                                          &#39;title&#39;: {&#39;text&#39;: &#34;&lt;i&gt;x&lt;/i&gt; (mm)&#34;}},
                                                 yaxis = {&#39;range&#39;: self._ylim,
                                                          &#39;title&#39;: {&#39;text&#39;: &#34;&lt;i&gt;y&lt;/i&gt; (mm)&#34;}},
                                                 zaxis = {&#39;range&#39;: self._zlim,
                                                          &#39;title&#39;: {&#39;text&#39;: &#34;&lt;i&gt;z&lt;/i&gt; (mm)&#34;}}
                                                 )

        return self._fig


    @property
    def xlim(self):
        &#39;&#39;&#39;The upper and lower limits of the *x*-axis.

        The property is defined as a list of length 2, formatted as
        [x_min, x_max]

        Returns
        -------
        xlim : list or numpy.ndarray
            A list of length 2 representing the upper and lower limits.

        &#39;&#39;&#39;

        return self._xlim


    @xlim.setter
    def xlim(self, new_xlim):
        &#39;&#39;&#39;Set the lower and upper boundaries of the *x*-axis

        Parameters
        ----------
        new_xlim : list or numpy.ndarray
            A list of length 2 representing the upper and lower limits of
            the *x*-axis, formatted as [x_min, x_max]

        Raises
        ------
        TypeError
            If `xlim`, `ylim` or `zlim` are not lists of length 2.
        AttributeError
            If no figure was created (i.e. create_figure was not called)

        &#39;&#39;&#39;

        if len(new_xlim) != 2:
            raise TypeError(&#34;\n[ERROR]: xlim, ylim and zlim need to be lists of length 2, formatted as xlim = [x_min, x_max] etc.\n&#34;)

        if self._fig is None:
            raise AttributeError(&#34;\n[ERROR]: No figure was created! First run create_figure()\n&#34;)

        self._xlim = new_xlim

        # For every subplot (scene), update axes&#39; limits
        # Plotly naming convention of scenes: &#39;scene&#39;, &#39;scene2&#39;, etc.
        for i in range(self._rows):
            for j in range(self._cols):
                if i == j == 0:
                    scene = &#39;scene&#39;
                else:
                    scene = &#39;scene{}&#39;.format(i * self._cols + j + 1)

                self._fig[&#39;layout&#39;][scene].update(xaxis = {&#39;range&#39;: self._xlim})


    @property
    def ylim(self):
        &#39;&#39;&#39;The upper and lower limits of the *y*-axis.

        The property is defined as a list of length 2, formatted as
        [y_min, y_max]

        Returns
        -------
        ylim : list or numpy.ndarray
            A list of length 2 representing the upper and lower limits.

        &#39;&#39;&#39;

        return self._ylim


    @ylim.setter
    def ylim(self, new_ylim):
        &#39;&#39;&#39;Set the lower and upper boundaries of the *y*-axis

        Parameters
        ----------
        new_ylim : list or numpy.ndarray
            A list of length 2 representing the upper and lower limits of
            the *y*-axis, formatted as [y_min, y_max]

        Raises
        ------
        TypeError
            If `xlim`, `ylim` or `zlim` are not lists of length 2.
        AttributeError
            If no figure was created (i.e. create_figure was not called)

        &#39;&#39;&#39;

        if len(new_ylim) != 2:
            raise TypeError(&#34;\n[ERROR]: xlim, ylim and zlim need to be lists of length 2, formatted as xlim = [x_min, x_max] etc.\n&#34;)

        if self._fig is None:
            raise AttributeError(&#34;\n[ERROR]: No figure was created! First run create_figure()\n&#34;)

        self._ylim = new_ylim

        # For every subplot (scene), update axes&#39; limits
        # Plotly naming convention of scenes: &#39;scene&#39;, &#39;scene2&#39;, etc.
        for i in range(self._rows):
            for j in range(self._cols):
                if i == j == 0:
                    scene = &#39;scene&#39;
                else:
                    scene = &#39;scene{}&#39;.format(i * self._cols + j + 1)

                self._fig[&#39;layout&#39;][scene].update(yaxis = {&#39;range&#39;: self._ylim})


    @property
    def zlim(self):
        &#39;&#39;&#39;The upper and lower limits of the *z*-axis.

        The property is defined as a list of length 2, formatted as
        [z_min, z_max]

        Returns
        -------
        zlim : list or numpy.ndarray
            A list of length 2 representing the upper and lower limits.

        &#39;&#39;&#39;

        return self._zlim


    @zlim.setter
    def zlim(self, new_zlim):
        &#39;&#39;&#39;Set the lower and upper boundaries of the *z*-axis

        Parameters
        ----------
        new_zlim : list or numpy.ndarray
            A list of length 2 representing the upper and lower limits of
            the *z*-axis, formatted as [z_min, z_max]

        Raises
        ------
        TypeError
            If `xlim`, `ylim` or `zlim` are not lists of length 2.
        AttributeError
            If no figure was created (i.e. create_figure was not called)

        &#39;&#39;&#39;

        if len(new_zlim) != 2:
            raise TypeError(&#34;\n[ERROR]: xlim, ylim and zlim need to be lists of length 2, formatted as xlim = [x_min, x_max] etc.\n&#34;)

        if self._fig is None:
            raise AttributeError(&#34;\n[ERROR]: No figure was created! First run create_figure()\n&#34;)

        self._zlim = new_zlim

        # For every subplot (scene), update axes&#39; limits
        # Plotly naming convention of scenes: &#39;scene&#39;, &#39;scene2&#39;, etc.
        for i in range(self._rows):
            for j in range(self._cols):
                if i == j == 0:
                    scene = &#39;scene&#39;
                else:
                    scene = &#39;scene{}&#39;.format(i * self._cols + j + 1)

                self._fig[&#39;layout&#39;][scene].update(zaxis = {&#39;range&#39;: self._zlim})


    @property
    def fig(self):
        &#39;&#39;&#39;Return the Plotly Figure instance

        This is useful for manual configuration of the Plotly figure
        stored in this class.

        Returns
        -------
        fig : Plotly Figure instance
            The Plotly Figure instance stored in the class, containing all
            data and options set.

        &#39;&#39;&#39;

        return self._fig


    def add_data_as_trace(self, data, row = 1, col = 1, size = 2, color = None):
        &#39;&#39;&#39;Create a Plotly trace of `data` and add it to the figure.

        Creates Scatter3d Plotly traces from the rows of `data` and adds it to
        the subplot determined by `row` and `col`.

        Parameters
        ----------
        data : (N, M &gt;= 4) numpy.ndarray
            The expected data row: [time, x, y, z, etc.]
        row : int, optional
            The row of the subplot to add a trace to. The default is 1.
        col : int, optional
            The column of the subplot to add a trace to. The default is 1.
        size : int, optional
            The size of the trace markers. The default is 2.
        color : str, optional
            The color of the trace markers. The default is `None`.

        Raises
        ------
        TypeError
            If `data` is not a numpy.ndarray with shape (N, M), where M &gt;= 4

        &#39;&#39;&#39;

        if data.ndim != 2 or data.shape[1] &lt; 4:
            raise TypeError(&#34;\n[ERROR]: data should be a numpy.ndarray with shape (N, M), where M &gt;= 4\n&#34;)

        trace = go.Scatter3d(
            x = data[:, 1],
            y = data[:, 2],
            z = data[:, 3],
            mode = &#39;markers&#39;,
            marker = dict(
                size = size,
                color = color,
                opacity = 0.8
            )
        )

        self._fig.add_trace(trace, row = row, col = col)


    def add_data_as_trace_colorbar(self, data,
                                   row = 1, col = 1,
                                   title_colorbar = None,
                                   size = 3, colorbar_col = -1):
        &#39;&#39;&#39;Create a colour-coded Plotly trace of `data` and add it to the figure.

        Creates Scatter3d Plotly traces from the rows of `data` and adds it to
        the subplot determined by `row` and `col`. It colour-codes the data in
        terms of a given column `colorbar_col` from the data.

        Parameters
        ----------
        data : (N, M &gt;= 4) numpy.ndarray
            The expected data row: [time, x, y, z, etc.]
        row : int, optional
            The row of the subplot to add a trace to. The default is 1.
        col : int, optional
            The column of the subplot to add a trace to. The default is 1.
        size : int, optional
            The size of the trace markers. The default is 2.
        title_colorbar : str, optional
            The title to display on the colorbar on the right of the plot.
            The default is `None`.
        colorbar_col : int, optional
            The column in `data` based on which the markers will be colour-coded.
            The default is -1, the last column.

        Raises
        ------
        TypeError
            If `data` is not a numpy.ndarray with shape (N, M), where M &gt;= 4
        ValueError
            If `colorbar_col` is larger than the number of columns in `data`

        &#39;&#39;&#39;

        if data.ndim != 2 or data.shape[1] &lt; 4:
            raise TypeError(&#34;\n[ERROR]: data should be a numpy.ndarray with shape (N, M), where M &gt;= 4\n&#34;)

        if colorbar_col &gt; data.shape[1]:
            raise ValueError(&#34;\n[ERROR]: colorbar_col was larger than the number of columns in data\n&#34;)

        if title_colorbar != None:
            colorbar = dict(title= title_colorbar)
        else:
            colorbar = dict()

        trace = go.Scatter3d(
            x = data[:, 1],
            y = data[:, 2],
            z = data[:, 3],
            mode = &#39;markers&#39;,
            marker = dict(
                size = size,
                color = data[:, colorbar_col],   # set color to sample size
                colorscale = &#39;Magma&#39;,     # choose a colorscale
                colorbar = colorbar,
                opacity = 0.8
            )
        )

        self._fig.add_trace(trace, row = row, col = col)


    def add_data_as_trace_line(self, data, row = 1, col = 1, width = 4, color = None):
        &#39;&#39;&#39;Create a Plotly trace of `data` and add it to the figure.

        Creates Scatter3d Plotly traces as continuous lines from the rows of
        `data` and adds it to the subplot determined by `row` and `col`.

        Parameters
        ----------
        data : (N, M &gt;= 4) numpy.ndarray
            The expected data row: [time, x, y, z, etc.]
        row : int, optional
            The row of the subplot to add a trace to. The default is 1.
        col : int, optional
            The column of the subplot to add a trace to. The default is 1.
        width : int, optional
            The width of the trace lines. The default is 4.
        color : str, optional
            The color of the trace markers. The default is `None`.

        Raises
        ------
        TypeError
            If `data` is not a numpy.ndarray with shape (N, M), where M &gt;= 4

        &#39;&#39;&#39;

        if data.ndim != 2 or data.shape[1] &lt; 4:
            raise TypeError(&#34;\n[ERROR]: data should be a numpy.ndarray with shape (N, M), where M &gt;= 4\n&#34;)

        trace = go.Scatter3d(
            x = data[:, 1],
            y = data[:, 2],
            z = data[:, 3],
            mode = &#39;lines&#39;,
            line = dict(
                width = width,
                color = color
            )
        )

        self._fig.add_trace(trace, row = row, col = col)


    def add_data_as_trace_lines(self, data, row = 1, col = 1, width = 2, color = None):
        &#39;&#39;&#39;Create Plotly traces for individual lines in `data` and add them to the figure.

        Creates Scatter3d Plotly traces as continuous lines from the rows of
        `data` and adds it to the subplot determined by `row` and `col`. It expects
        LoR-like data, where every line is defined by two points.

        Parameters
        ----------
        data : (N, M &gt;= 7) numpy.ndarray
            The expected data row: [time, x1, y1, z1, x2, y2, z2, etc.]
        row : int, optional
            The row of the subplot to add a trace to. The default is 1.
        col : int, optional
            The column of the subplot to add a trace to. The default is 1.
        width : int, optional
            The width of the trace lines. The default is 4.
        color : str, optional
            The color of the trace markers. The default is `None`.

        Raises
        ------
        TypeError
            If `data` is not a numpy.ndarray with shape (N, M), where M &gt;= 7

        &#39;&#39;&#39;

        if data.ndim != 2 or data.shape[1] &lt; 7:
            raise TypeError(&#34;\n[ERROR]: data should be a numpy.ndarray with shape (N, M), where M &gt;= 7\n&#34;)


        # data is a list of lines, each defined by two points
        # data row [time, x1, y1, z1, x2, y2, z2]
        for line in data:
            self._fig.add_trace(
                go.Scatter3d(
                    x = [ line[1], line[4] ],
                    y = [ line[2], line[5] ],
                    z = [ line[3], line[6] ],
                    mode = &#39;lines&#39;,
                    opacity = 0.6,
                    line = dict(
                        width = width,
                        color = color
                    )
                ),
                row = row,
                col = col
                        )


    def add_trace(self, trace, row = 1, col = 1):
        &#39;&#39;&#39;Add a precomputed Plotly trace to a given subplot.

        The equivalent of the Plotly figure.add_trace method.

        Parameters
        ----------
        trace : Plotly trace (Scatter3d)
            A precomputed Plotly trace
        row : int, optional
            The row of the subplot to add a trace to. The default is 1.
        col : int, optional
            The column of the subplot to add a trace to. The default is 1.

        &#39;&#39;&#39;

        # Add precomputed trace
        self._fig.add_trace(trace, row = row, col = col)


    def add_traces(self, traces, row = 1, col = 1):
        &#39;&#39;&#39;Add a list of precomputed Plotly traces to a given subplot.

        The equivalent of the Plotly figure.add_traces method.

        Parameters
        ----------
        traces : list [ Plotly trace (Scatter3d) ]
            A list of precomputed Plotly traces
        row : int, optional
            The row of the subplot to add a trace to. The default is 1.
        col : int, optional
            The column of the subplot to add a trace to. The default is 1.

        &#39;&#39;&#39;

        # Add precomputed traces
        self._fig.add_traces(traces, rows=[row]*len(traces), cols=[col]*len(traces))


    def show(self):
        &#39;&#39;&#39;Show the Plotly figure.

        &#39;&#39;&#39;

        self._fig.show()</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pept.visualisation.PlotlyGrapher.fig"><code class="name">var <span class="ident">fig</span></code></dt>
<dd>
<section class="desc"><p>Return the Plotly Figure instance</p>
<p>This is useful for manual configuration of the Plotly figure
stored in this class.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>Plotly</code> <code>Figure</code> <code>instance</code></dt>
<dd>The Plotly Figure instance stored in the class, containing all
data and options set.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def fig(self):
    &#39;&#39;&#39;Return the Plotly Figure instance

    This is useful for manual configuration of the Plotly figure
    stored in this class.

    Returns
    -------
    fig : Plotly Figure instance
        The Plotly Figure instance stored in the class, containing all
        data and options set.

    &#39;&#39;&#39;

    return self._fig</code></pre>
</details>
</dd>
<dt id="pept.visualisation.PlotlyGrapher.xlim"><code class="name">var <span class="ident">xlim</span></code></dt>
<dd>
<section class="desc"><p>The upper and lower limits of the <em>x</em>-axis.</p>
<p>The property is defined as a list of length 2, formatted as
[x_min, x_max]</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>xlim</code></strong> :&ensp;<code>list</code> or <code>numpy.ndarray</code></dt>
<dd>A list of length 2 representing the upper and lower limits.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def xlim(self):
    &#39;&#39;&#39;The upper and lower limits of the *x*-axis.

    The property is defined as a list of length 2, formatted as
    [x_min, x_max]

    Returns
    -------
    xlim : list or numpy.ndarray
        A list of length 2 representing the upper and lower limits.

    &#39;&#39;&#39;

    return self._xlim</code></pre>
</details>
</dd>
<dt id="pept.visualisation.PlotlyGrapher.ylim"><code class="name">var <span class="ident">ylim</span></code></dt>
<dd>
<section class="desc"><p>The upper and lower limits of the <em>y</em>-axis.</p>
<p>The property is defined as a list of length 2, formatted as
[y_min, y_max]</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ylim</code></strong> :&ensp;<code>list</code> or <code>numpy.ndarray</code></dt>
<dd>A list of length 2 representing the upper and lower limits.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def ylim(self):
    &#39;&#39;&#39;The upper and lower limits of the *y*-axis.

    The property is defined as a list of length 2, formatted as
    [y_min, y_max]

    Returns
    -------
    ylim : list or numpy.ndarray
        A list of length 2 representing the upper and lower limits.

    &#39;&#39;&#39;

    return self._ylim</code></pre>
</details>
</dd>
<dt id="pept.visualisation.PlotlyGrapher.zlim"><code class="name">var <span class="ident">zlim</span></code></dt>
<dd>
<section class="desc"><p>The upper and lower limits of the <em>z</em>-axis.</p>
<p>The property is defined as a list of length 2, formatted as
[z_min, z_max]</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>zlim</code></strong> :&ensp;<code>list</code> or <code>numpy.ndarray</code></dt>
<dd>A list of length 2 representing the upper and lower limits.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def zlim(self):
    &#39;&#39;&#39;The upper and lower limits of the *z*-axis.

    The property is defined as a list of length 2, formatted as
    [z_min, z_max]

    Returns
    -------
    zlim : list or numpy.ndarray
        A list of length 2 representing the upper and lower limits.

    &#39;&#39;&#39;

    return self._zlim</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pept.visualisation.PlotlyGrapher.add_data_as_trace"><code class="name flex">
<span>def <span class="ident">add_data_as_trace</span></span>(<span>self, data, row=1, col=1, size=2, color=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Create a Plotly trace of <code>data</code> and add it to the figure.</p>
<p>Creates Scatter3d Plotly traces from the rows of <code>data</code> and adds it to
the subplot determined by <code>row</code> and <code>col</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;(<code>N</code>, <code>M</code> &gt;= <code>4</code>) <code>numpy.ndarray</code></dt>
<dd>The expected data row: [time, x, y, z, etc.]</dd>
<dt><strong><code>row</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The row of the subplot to add a trace to. The default is 1.</dd>
<dt><strong><code>col</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The column of the subplot to add a trace to. The default is 1.</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The size of the trace markers. The default is 2.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The color of the trace markers. The default is <code>None</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>data</code> is not a numpy.ndarray with shape (N, M), where M &gt;= 4</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_data_as_trace(self, data, row = 1, col = 1, size = 2, color = None):
    &#39;&#39;&#39;Create a Plotly trace of `data` and add it to the figure.

    Creates Scatter3d Plotly traces from the rows of `data` and adds it to
    the subplot determined by `row` and `col`.

    Parameters
    ----------
    data : (N, M &gt;= 4) numpy.ndarray
        The expected data row: [time, x, y, z, etc.]
    row : int, optional
        The row of the subplot to add a trace to. The default is 1.
    col : int, optional
        The column of the subplot to add a trace to. The default is 1.
    size : int, optional
        The size of the trace markers. The default is 2.
    color : str, optional
        The color of the trace markers. The default is `None`.

    Raises
    ------
    TypeError
        If `data` is not a numpy.ndarray with shape (N, M), where M &gt;= 4

    &#39;&#39;&#39;

    if data.ndim != 2 or data.shape[1] &lt; 4:
        raise TypeError(&#34;\n[ERROR]: data should be a numpy.ndarray with shape (N, M), where M &gt;= 4\n&#34;)

    trace = go.Scatter3d(
        x = data[:, 1],
        y = data[:, 2],
        z = data[:, 3],
        mode = &#39;markers&#39;,
        marker = dict(
            size = size,
            color = color,
            opacity = 0.8
        )
    )

    self._fig.add_trace(trace, row = row, col = col)</code></pre>
</details>
</dd>
<dt id="pept.visualisation.PlotlyGrapher.add_data_as_trace_colorbar"><code class="name flex">
<span>def <span class="ident">add_data_as_trace_colorbar</span></span>(<span>self, data, row=1, col=1, title_colorbar=None, size=3, colorbar_col=-1)</span>
</code></dt>
<dd>
<section class="desc"><p>Create a colour-coded Plotly trace of <code>data</code> and add it to the figure.</p>
<p>Creates Scatter3d Plotly traces from the rows of <code>data</code> and adds it to
the subplot determined by <code>row</code> and <code>col</code>. It colour-codes the data in
terms of a given column <code>colorbar_col</code> from the data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;(<code>N</code>, <code>M</code> &gt;= <code>4</code>) <code>numpy.ndarray</code></dt>
<dd>The expected data row: [time, x, y, z, etc.]</dd>
<dt><strong><code>row</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The row of the subplot to add a trace to. The default is 1.</dd>
<dt><strong><code>col</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The column of the subplot to add a trace to. The default is 1.</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The size of the trace markers. The default is 2.</dd>
<dt><strong><code>title_colorbar</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The title to display on the colorbar on the right of the plot.
The default is <code>None</code>.</dd>
<dt><strong><code>colorbar_col</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The column in <code>data</code> based on which the markers will be colour-coded.
The default is -1, the last column.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>data</code> is not a numpy.ndarray with shape (N, M), where M &gt;= 4</dd>
<dt><code>ValueError</code></dt>
<dd>If <code>colorbar_col</code> is larger than the number of columns in <code>data</code></dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_data_as_trace_colorbar(self, data,
                               row = 1, col = 1,
                               title_colorbar = None,
                               size = 3, colorbar_col = -1):
    &#39;&#39;&#39;Create a colour-coded Plotly trace of `data` and add it to the figure.

    Creates Scatter3d Plotly traces from the rows of `data` and adds it to
    the subplot determined by `row` and `col`. It colour-codes the data in
    terms of a given column `colorbar_col` from the data.

    Parameters
    ----------
    data : (N, M &gt;= 4) numpy.ndarray
        The expected data row: [time, x, y, z, etc.]
    row : int, optional
        The row of the subplot to add a trace to. The default is 1.
    col : int, optional
        The column of the subplot to add a trace to. The default is 1.
    size : int, optional
        The size of the trace markers. The default is 2.
    title_colorbar : str, optional
        The title to display on the colorbar on the right of the plot.
        The default is `None`.
    colorbar_col : int, optional
        The column in `data` based on which the markers will be colour-coded.
        The default is -1, the last column.

    Raises
    ------
    TypeError
        If `data` is not a numpy.ndarray with shape (N, M), where M &gt;= 4
    ValueError
        If `colorbar_col` is larger than the number of columns in `data`

    &#39;&#39;&#39;

    if data.ndim != 2 or data.shape[1] &lt; 4:
        raise TypeError(&#34;\n[ERROR]: data should be a numpy.ndarray with shape (N, M), where M &gt;= 4\n&#34;)

    if colorbar_col &gt; data.shape[1]:
        raise ValueError(&#34;\n[ERROR]: colorbar_col was larger than the number of columns in data\n&#34;)

    if title_colorbar != None:
        colorbar = dict(title= title_colorbar)
    else:
        colorbar = dict()

    trace = go.Scatter3d(
        x = data[:, 1],
        y = data[:, 2],
        z = data[:, 3],
        mode = &#39;markers&#39;,
        marker = dict(
            size = size,
            color = data[:, colorbar_col],   # set color to sample size
            colorscale = &#39;Magma&#39;,     # choose a colorscale
            colorbar = colorbar,
            opacity = 0.8
        )
    )

    self._fig.add_trace(trace, row = row, col = col)</code></pre>
</details>
</dd>
<dt id="pept.visualisation.PlotlyGrapher.add_data_as_trace_line"><code class="name flex">
<span>def <span class="ident">add_data_as_trace_line</span></span>(<span>self, data, row=1, col=1, width=4, color=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Create a Plotly trace of <code>data</code> and add it to the figure.</p>
<p>Creates Scatter3d Plotly traces as continuous lines from the rows of
<code>data</code> and adds it to the subplot determined by <code>row</code> and <code>col</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;(<code>N</code>, <code>M</code> &gt;= <code>4</code>) <code>numpy.ndarray</code></dt>
<dd>The expected data row: [time, x, y, z, etc.]</dd>
<dt><strong><code>row</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The row of the subplot to add a trace to. The default is 1.</dd>
<dt><strong><code>col</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The column of the subplot to add a trace to. The default is 1.</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The width of the trace lines. The default is 4.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The color of the trace markers. The default is <code>None</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>data</code> is not a numpy.ndarray with shape (N, M), where M &gt;= 4</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_data_as_trace_line(self, data, row = 1, col = 1, width = 4, color = None):
    &#39;&#39;&#39;Create a Plotly trace of `data` and add it to the figure.

    Creates Scatter3d Plotly traces as continuous lines from the rows of
    `data` and adds it to the subplot determined by `row` and `col`.

    Parameters
    ----------
    data : (N, M &gt;= 4) numpy.ndarray
        The expected data row: [time, x, y, z, etc.]
    row : int, optional
        The row of the subplot to add a trace to. The default is 1.
    col : int, optional
        The column of the subplot to add a trace to. The default is 1.
    width : int, optional
        The width of the trace lines. The default is 4.
    color : str, optional
        The color of the trace markers. The default is `None`.

    Raises
    ------
    TypeError
        If `data` is not a numpy.ndarray with shape (N, M), where M &gt;= 4

    &#39;&#39;&#39;

    if data.ndim != 2 or data.shape[1] &lt; 4:
        raise TypeError(&#34;\n[ERROR]: data should be a numpy.ndarray with shape (N, M), where M &gt;= 4\n&#34;)

    trace = go.Scatter3d(
        x = data[:, 1],
        y = data[:, 2],
        z = data[:, 3],
        mode = &#39;lines&#39;,
        line = dict(
            width = width,
            color = color
        )
    )

    self._fig.add_trace(trace, row = row, col = col)</code></pre>
</details>
</dd>
<dt id="pept.visualisation.PlotlyGrapher.add_data_as_trace_lines"><code class="name flex">
<span>def <span class="ident">add_data_as_trace_lines</span></span>(<span>self, data, row=1, col=1, width=2, color=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Create Plotly traces for individual lines in <code>data</code> and add them to the figure.</p>
<p>Creates Scatter3d Plotly traces as continuous lines from the rows of
<code>data</code> and adds it to the subplot determined by <code>row</code> and <code>col</code>. It expects
LoR-like data, where every line is defined by two points.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;(<code>N</code>, <code>M</code> &gt;= <code>7</code>) <code>numpy.ndarray</code></dt>
<dd>The expected data row: [time, x1, y1, z1, x2, y2, z2, etc.]</dd>
<dt><strong><code>row</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The row of the subplot to add a trace to. The default is 1.</dd>
<dt><strong><code>col</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The column of the subplot to add a trace to. The default is 1.</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The width of the trace lines. The default is 4.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The color of the trace markers. The default is <code>None</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>data</code> is not a numpy.ndarray with shape (N, M), where M &gt;= 7</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_data_as_trace_lines(self, data, row = 1, col = 1, width = 2, color = None):
    &#39;&#39;&#39;Create Plotly traces for individual lines in `data` and add them to the figure.

    Creates Scatter3d Plotly traces as continuous lines from the rows of
    `data` and adds it to the subplot determined by `row` and `col`. It expects
    LoR-like data, where every line is defined by two points.

    Parameters
    ----------
    data : (N, M &gt;= 7) numpy.ndarray
        The expected data row: [time, x1, y1, z1, x2, y2, z2, etc.]
    row : int, optional
        The row of the subplot to add a trace to. The default is 1.
    col : int, optional
        The column of the subplot to add a trace to. The default is 1.
    width : int, optional
        The width of the trace lines. The default is 4.
    color : str, optional
        The color of the trace markers. The default is `None`.

    Raises
    ------
    TypeError
        If `data` is not a numpy.ndarray with shape (N, M), where M &gt;= 7

    &#39;&#39;&#39;

    if data.ndim != 2 or data.shape[1] &lt; 7:
        raise TypeError(&#34;\n[ERROR]: data should be a numpy.ndarray with shape (N, M), where M &gt;= 7\n&#34;)


    # data is a list of lines, each defined by two points
    # data row [time, x1, y1, z1, x2, y2, z2]
    for line in data:
        self._fig.add_trace(
            go.Scatter3d(
                x = [ line[1], line[4] ],
                y = [ line[2], line[5] ],
                z = [ line[3], line[6] ],
                mode = &#39;lines&#39;,
                opacity = 0.6,
                line = dict(
                    width = width,
                    color = color
                )
            ),
            row = row,
            col = col
                    )</code></pre>
</details>
</dd>
<dt id="pept.visualisation.PlotlyGrapher.add_trace"><code class="name flex">
<span>def <span class="ident">add_trace</span></span>(<span>self, trace, row=1, col=1)</span>
</code></dt>
<dd>
<section class="desc"><p>Add a precomputed Plotly trace to a given subplot.</p>
<p>The equivalent of the Plotly figure.add_trace method.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>trace</code></strong> :&ensp;<code>Plotly</code> <code>trace</code> (<code>Scatter3d</code>)</dt>
<dd>A precomputed Plotly trace</dd>
<dt><strong><code>row</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The row of the subplot to add a trace to. The default is 1.</dd>
<dt><strong><code>col</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The column of the subplot to add a trace to. The default is 1.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_trace(self, trace, row = 1, col = 1):
    &#39;&#39;&#39;Add a precomputed Plotly trace to a given subplot.

    The equivalent of the Plotly figure.add_trace method.

    Parameters
    ----------
    trace : Plotly trace (Scatter3d)
        A precomputed Plotly trace
    row : int, optional
        The row of the subplot to add a trace to. The default is 1.
    col : int, optional
        The column of the subplot to add a trace to. The default is 1.

    &#39;&#39;&#39;

    # Add precomputed trace
    self._fig.add_trace(trace, row = row, col = col)</code></pre>
</details>
</dd>
<dt id="pept.visualisation.PlotlyGrapher.add_traces"><code class="name flex">
<span>def <span class="ident">add_traces</span></span>(<span>self, traces, row=1, col=1)</span>
</code></dt>
<dd>
<section class="desc"><p>Add a list of precomputed Plotly traces to a given subplot.</p>
<p>The equivalent of the Plotly figure.add_traces method.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>traces</code></strong> :&ensp;<code>list</code> [ <code>Plotly</code> <code>trace</code> (<code>Scatter3d</code>) ]</dt>
<dd>A list of precomputed Plotly traces</dd>
<dt><strong><code>row</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The row of the subplot to add a trace to. The default is 1.</dd>
<dt><strong><code>col</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The column of the subplot to add a trace to. The default is 1.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_traces(self, traces, row = 1, col = 1):
    &#39;&#39;&#39;Add a list of precomputed Plotly traces to a given subplot.

    The equivalent of the Plotly figure.add_traces method.

    Parameters
    ----------
    traces : list [ Plotly trace (Scatter3d) ]
        A list of precomputed Plotly traces
    row : int, optional
        The row of the subplot to add a trace to. The default is 1.
    col : int, optional
        The column of the subplot to add a trace to. The default is 1.

    &#39;&#39;&#39;

    # Add precomputed traces
    self._fig.add_traces(traces, rows=[row]*len(traces), cols=[col]*len(traces))</code></pre>
</details>
</dd>
<dt id="pept.visualisation.PlotlyGrapher.create_figure"><code class="name flex">
<span>def <span class="ident">create_figure</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Create a Plotly figure, pre-configured for PEPT data.</p>
<p>This function creates a Plotly figure with any number of subplots,
as given in the class instantiation call. It pre-configures them to have
the <em>y</em>-axis pointing upwards, as per the PEPT 3D axes convention. It
also sets the axes limits and labels.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>Plotly</code> <code>Figure</code> <code>instance</code></dt>
<dd>A Plotly Figure instance, with any number of subplots (as defined when instantiating
the class) pre-configured for PEPT data.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def create_figure(self):
    &#39;&#39;&#39;Create a Plotly figure, pre-configured for PEPT data.

    This function creates a Plotly figure with any number of subplots,
    as given in the class instantiation call. It pre-configures them to have
    the *y*-axis pointing upwards, as per the PEPT 3D axes convention. It
    also sets the axes limits and labels.

    Returns
    -------
    fig : Plotly Figure instance
        A Plotly Figure instance, with any number of subplots (as defined when instantiating
        the class) pre-configured for PEPT data.

    &#39;&#39;&#39;

    specs = [[{&#34;type&#34;: &#34;scatter3d&#34;}] * self._cols] * self._rows

    self._fig = make_subplots(rows = self._rows, cols = self._cols,
                specs = specs, subplot_titles = self._subplot_titles,
                horizontal_spacing = 0.005, vertical_spacing = 0.05)

    self._fig[&#39;layout&#39;].update(margin = dict(l=0,r=0,b=30,t=30), showlegend = False)

    # For every subplot (scene), set axes&#39; ratios and limits
    # Also set the y axis to point upwards
    # Plotly naming convention of scenes: &#39;scene&#39;, &#39;scene2&#39;, etc.
    for i in range(self._rows):
        for j in range(self._cols):
            if i == j == 0:
                scene = &#39;scene&#39;
            else:
                scene = &#39;scene{}&#39;.format(i * self._cols + j + 1)

            # Justify subplot title on the left
            self._fig.layout.annotations[i * self._cols + j].update(x = (j + 0.15) / self._cols)
            self._fig[&#39;layout&#39;][scene].update(aspectmode = &#39;manual&#39;,
                                             aspectratio = {&#39;x&#39;: 1, &#39;y&#39;: 1, &#39;z&#39;: 1},
                                             camera = {&#39;up&#39;: {&#39;x&#39;: 0, &#39;y&#39;: 1, &#39;z&#39;:0},
                                                       &#39;eye&#39;: {&#39;x&#39;: 1, &#39;y&#39;: 1, &#39;z&#39;: 1}},
                                             xaxis = {&#39;range&#39;: self._xlim,
                                                      &#39;title&#39;: {&#39;text&#39;: &#34;&lt;i&gt;x&lt;/i&gt; (mm)&#34;}},
                                             yaxis = {&#39;range&#39;: self._ylim,
                                                      &#39;title&#39;: {&#39;text&#39;: &#34;&lt;i&gt;y&lt;/i&gt; (mm)&#34;}},
                                             zaxis = {&#39;range&#39;: self._zlim,
                                                      &#39;title&#39;: {&#39;text&#39;: &#34;&lt;i&gt;z&lt;/i&gt; (mm)&#34;}}
                                             )

    return self._fig</code></pre>
</details>
</dd>
<dt id="pept.visualisation.PlotlyGrapher.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Show the Plotly figure.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def show(self):
    &#39;&#39;&#39;Show the Plotly figure.

    &#39;&#39;&#39;

    self._fig.show()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pept" href="../index.html">pept</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="pept.visualisation.plotly_grapher" href="plotly_grapher.html">pept.visualisation.plotly_grapher</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pept.visualisation.PlotlyGrapher" href="#pept.visualisation.PlotlyGrapher">PlotlyGrapher</a></code></h4>
<ul class="">
<li><code><a title="pept.visualisation.PlotlyGrapher.add_data_as_trace" href="#pept.visualisation.PlotlyGrapher.add_data_as_trace">add_data_as_trace</a></code></li>
<li><code><a title="pept.visualisation.PlotlyGrapher.add_data_as_trace_colorbar" href="#pept.visualisation.PlotlyGrapher.add_data_as_trace_colorbar">add_data_as_trace_colorbar</a></code></li>
<li><code><a title="pept.visualisation.PlotlyGrapher.add_data_as_trace_line" href="#pept.visualisation.PlotlyGrapher.add_data_as_trace_line">add_data_as_trace_line</a></code></li>
<li><code><a title="pept.visualisation.PlotlyGrapher.add_data_as_trace_lines" href="#pept.visualisation.PlotlyGrapher.add_data_as_trace_lines">add_data_as_trace_lines</a></code></li>
<li><code><a title="pept.visualisation.PlotlyGrapher.add_trace" href="#pept.visualisation.PlotlyGrapher.add_trace">add_trace</a></code></li>
<li><code><a title="pept.visualisation.PlotlyGrapher.add_traces" href="#pept.visualisation.PlotlyGrapher.add_traces">add_traces</a></code></li>
<li><code><a title="pept.visualisation.PlotlyGrapher.create_figure" href="#pept.visualisation.PlotlyGrapher.create_figure">create_figure</a></code></li>
<li><code><a title="pept.visualisation.PlotlyGrapher.fig" href="#pept.visualisation.PlotlyGrapher.fig">fig</a></code></li>
<li><code><a title="pept.visualisation.PlotlyGrapher.show" href="#pept.visualisation.PlotlyGrapher.show">show</a></code></li>
<li><code><a title="pept.visualisation.PlotlyGrapher.xlim" href="#pept.visualisation.PlotlyGrapher.xlim">xlim</a></code></li>
<li><code><a title="pept.visualisation.PlotlyGrapher.ylim" href="#pept.visualisation.PlotlyGrapher.ylim">ylim</a></code></li>
<li><code><a title="pept.visualisation.PlotlyGrapher.zlim" href="#pept.visualisation.PlotlyGrapher.zlim">zlim</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>